"""
Vulnerability-Weighted Ethical Penalties
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Implements ethical penalty scoring that weights decisions based on population
vulnerability to prevent AI from optimizing for "easy" populations while
neglecting vulnerable groups.

Cognitive Hardening Protocol:
- Penalizes AI decisions that ignore vulnerable populations
- Weights refugee camps, conflict zones, and marginalized communities higher
- Prevents optimization bias toward well-resourced areas
- Enforces equity in outbreak response

Compliance:
- UN Humanitarian Principles (Humanity, Impartiality, Neutrality, Independence)
- Geneva Convention Article 3 (Protection of Vulnerable Populations)
- WHO IHR Article 3 (Principles - Respect for Dignity, Human Rights, Fundamental Freedoms)
"""

from typing import Dict, Any, List
from enum import Enum
import logging
import json

logger = logging.getLogger(__name__)


class VulnerabilityCategory(Enum):
    """Population vulnerability categories"""
    REFUGEE_CAMP = 5.0  # Highest vulnerability
    CONFLICT_ZONE = 4.5
    INFORMAL_SETTLEMENT = 4.0
    RURAL_REMOTE = 3.5
    URBAN_POOR = 3.0
    PERI_URBAN = 2.0
    URBAN_MIDDLE = 1.5
    URBAN_WEALTHY = 1.0  # Baseline


class ResourceAvailability(Enum):
    """Healthcare resource availability"""
    NONE = 5.0  # No healthcare access
    MINIMAL = 4.0  # CHV only
    BASIC = 3.0  # Health post
    MODERATE = 2.0  # Health center
    FULL = 1.0  # Hospital


class PopulationRisk(Enum):
    """Population-specific risk factors"""
    CHILDREN_UNDER_5 = 2.0
    PREGNANT_WOMEN = 1.8
    ELDERLY = 1.6
    IMMUNOCOMPROMISED = 2.5
    MALNOURISHED = 2.2
    DISPLACED = 1.9
    GENERAL = 1.0


class VulnerabilityWeightedPenalty:
    """
    Calculates ethical penalties for AI decisions based on population vulnerability.
    
    Prevents AI from optimizing for "easy wins" in well-resourced areas while
    neglecting vulnerable populations.
    """
    
    def __init__(self, enable_audit: bool = True):
        self.enable_audit = enable_audit
        self.audit_log = []
        
        logger.info("âš–ï¸  Vulnerability-Weighted Penalty system initialized")
    
    def calculate_penalty(
        self,
        decision: Dict[str, Any],
        population_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Calculate ethical penalty for a decision based on population vulnerability.
        
        Args:
            decision: AI decision (resource allocation, response priority, etc.)
            population_context: Context about the affected population
        
        Returns:
            Penalty score and breakdown
        """
        # Extract context
        vulnerability = population_context.get("vulnerability_category", "URBAN_MIDDLE")
        resource_availability = population_context.get("resource_availability", "MODERATE")
        population_risks = population_context.get("population_risks", ["GENERAL"])
        population_size = population_context.get("population_size", 1000)
        
        # Get vulnerability weight
        vuln_weight = self._get_vulnerability_weight(vulnerability)
        
        # Get resource scarcity weight
        resource_weight = self._get_resource_weight(resource_availability)
        
        # Get population risk weight
        risk_weight = self._get_population_risk_weight(population_risks)
        
        # Calculate base penalty
        base_penalty = vuln_weight * resource_weight * risk_weight
        
        # Scale by population size (logarithmic to prevent overwhelming)
        import math
        population_factor = math.log10(population_size) / 3.0  # Normalize to ~1.0 for 1000 people
        
        # Final penalty
        final_penalty = base_penalty * population_factor
        
        # Check if decision adequately addresses vulnerability
        decision_adequacy = self._assess_decision_adequacy(decision, population_context)
        
        # Apply penalty if decision is inadequate
        if not decision_adequacy["adequate"]:
            penalty_multiplier = 2.0  # Double penalty for inadequate response
            final_penalty *= penalty_multiplier
        else:
            penalty_multiplier = 1.0
        
        result = {
            "penalty_score": final_penalty,
            "vulnerability_weight": vuln_weight,
            "resource_weight": resource_weight,
            "risk_weight": risk_weight,
            "population_factor": population_factor,
            "penalty_multiplier": penalty_multiplier,
            "decision_adequate": decision_adequacy["adequate"],
            "adequacy_reasons": decision_adequacy["reasons"],
            "severity": self._classify_penalty_severity(final_penalty),
            "recommendations": self._generate_recommendations(
                final_penalty,
                population_context,
                decision_adequacy
            )
        }
        
        # Audit log
        if self.enable_audit:
            self._log_penalty(decision, population_context, result)
        
        logger.info(
            f"âš–ï¸  Penalty calculated: {final_penalty:.2f} "
            f"(Severity: {result['severity']}, Adequate: {decision_adequacy['adequate']})"
        )
        
        return result
    
    def _get_vulnerability_weight(self, category: str) -> float:
        """Get vulnerability weight for population category"""
        try:
            return VulnerabilityCategory[category].value
        except KeyError:
            logger.warning(f"Unknown vulnerability category: {category}, using URBAN_MIDDLE")
            return VulnerabilityCategory.URBAN_MIDDLE.value
    
    def _get_resource_weight(self, availability: str) -> float:
        """Get resource scarcity weight"""
        try:
            return ResourceAvailability[availability].value
        except KeyError:
            logger.warning(f"Unknown resource availability: {availability}, using MODERATE")
            return ResourceAvailability.MODERATE.value
    
    def _get_population_risk_weight(self, risks: List[str]) -> float:
        """Get combined population risk weight"""
        total_weight = 1.0
        
        for risk in risks:
            try:
                weight = PopulationRisk[risk].value
                total_weight *= weight
            except KeyError:
                logger.warning(f"Unknown population risk: {risk}, skipping")
        
        return total_weight
    
    def _assess_decision_adequacy(
        self,
        decision: Dict[str, Any],
        population_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Assess if decision adequately addresses population vulnerability.
        
        Returns:
            adequacy assessment with reasons
        """
        reasons = []
        adequate = True
        
        # Check resource allocation
        allocated_resources = decision.get("allocated_resources", 0)
        required_resources = population_context.get("required_resources", 100)
        
        if allocated_resources < required_resources * 0.8:  # 80% threshold
            adequate = False
            reasons.append(
                f"Insufficient resources: {allocated_resources} < {required_resources * 0.8:.0f} required"
            )
        
        # Check response time
        response_time_hours = decision.get("response_time_hours", 24)
        vulnerability = population_context.get("vulnerability_category", "URBAN_MIDDLE")
        
        # High vulnerability requires faster response
        if vulnerability in ["REFUGEE_CAMP", "CONFLICT_ZONE"]:
            max_response_time = 4  # 4 hours
        elif vulnerability in ["INFORMAL_SETTLEMENT", "RURAL_REMOTE"]:
            max_response_time = 12  # 12 hours
        else:
            max_response_time = 24  # 24 hours
        
        if response_time_hours > max_response_time:
            adequate = False
            reasons.append(
                f"Response too slow: {response_time_hours}h > {max_response_time}h required"
            )
        
        # Check intervention type
        intervention = decision.get("intervention_type", "standard")
        
        if vulnerability in ["REFUGEE_CAMP", "CONFLICT_ZONE"] and intervention == "standard":
            adequate = False
            reasons.append(
                "Standard intervention insufficient for high-vulnerability population"
            )
        
        if adequate:
            reasons.append("Decision adequately addresses population vulnerability")
        
        return {
            "adequate": adequate,
            "reasons": reasons
        }
    
    def _classify_penalty_severity(self, penalty_score: float) -> str:
        """Classify penalty severity"""
        if penalty_score >= 50:
            return "CRITICAL"
        elif penalty_score >= 30:
            return "HIGH"
        elif penalty_score >= 15:
            return "MODERATE"
        elif penalty_score >= 5:
            return "LOW"
        else:
            return "MINIMAL"
    
    def _generate_recommendations(
        self,
        penalty_score: float,
        population_context: Dict[str, Any],
        decision_adequacy: Dict[str, Any]
    ) -> List[str]:
        """Generate recommendations to reduce penalty"""
        recommendations = []
        
        if penalty_score >= 30:
            recommendations.append(
                "ðŸš¨ CRITICAL: Immediate escalation to humanitarian response coordinator required"
            )
        
        if not decision_adequacy["adequate"]:
            recommendations.append(
                "âš ï¸  Decision inadequate for population vulnerability - revise allocation"
            )
        
        vulnerability = population_context.get("vulnerability_category", "URBAN_MIDDLE")
        
        if vulnerability in ["REFUGEE_CAMP", "CONFLICT_ZONE"]:
            recommendations.append(
                "ðŸ•ï¸  High-vulnerability population: Deploy mobile health units and emergency supplies"
            )
            recommendations.append(
                "ðŸ“¡ Establish LoRa mesh network for offline communication"
            )
        
        if vulnerability in ["RURAL_REMOTE", "INFORMAL_SETTLEMENT"]:
            recommendations.append(
                "ðŸš Consider air transport for critical supplies"
            )
        
        resource_availability = population_context.get("resource_availability", "MODERATE")
        
        if resource_availability in ["NONE", "MINIMAL"]:
            recommendations.append(
                "ðŸ¥ Deploy CHV teams with emergency kits"
            )
            recommendations.append(
                "ðŸ’‰ Pre-position vaccines and ORS supplies"
            )
        
        return recommendations
    
    def _log_penalty(
        self,
        decision: Dict[str, Any],
        population_context: Dict[str, Any],
        result: Dict[str, Any]
    ):
        """Log penalty to audit trail"""
        from datetime import datetime
        
        audit_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "decision": decision,
            "population_context": population_context,
            "penalty_result": result
        }
        
        self.audit_log.append(audit_entry)
        
        # Persist to file
        try:
            with open("logs/vulnerability_penalties.jsonl", 'a') as f:
                f.write(json.dumps(audit_entry) + '\n')
        except Exception as e:
            logger.error(f"Failed to write audit log: {e}")
    
    def get_penalty_statistics(self) -> Dict[str, Any]:
        """Get statistics on penalties"""
        if not self.audit_log:
            return {"total_penalties": 0}
        
        total = len(self.audit_log)
        penalties = [entry["penalty_result"]["penalty_score"] for entry in self.audit_log]
        
        return {
            "total_penalties": total,
            "average_penalty": sum(penalties) / total,
            "max_penalty": max(penalties),
            "min_penalty": min(penalties),
            "critical_count": sum(1 for p in penalties if p >= 50),
            "high_count": sum(1 for p in penalties if 30 <= p < 50),
            "moderate_count": sum(1 for p in penalties if 15 <= p < 30)
        }


# Example usage
if __name__ == "__main__":
    penalty_system = VulnerabilityWeightedPenalty()
    
    # Scenario 1: Refugee camp with inadequate response
    decision_1 = {
        "allocated_resources": 50,
        "response_time_hours": 12,
        "intervention_type": "standard"
    }
    
    population_1 = {
        "vulnerability_category": "REFUGEE_CAMP",
        "resource_availability": "MINIMAL",
        "population_risks": ["CHILDREN_UNDER_5", "MALNOURISHED"],
        "population_size": 50000,
        "required_resources": 200
    }
    
    result_1 = penalty_system.calculate_penalty(decision_1, population_1)
    print("Scenario 1: Refugee Camp")
    print(json.dumps(result_1, indent=2))
    print()
    
    # Scenario 2: Urban area with adequate response
    decision_2 = {
        "allocated_resources": 150,
        "response_time_hours": 6,
        "intervention_type": "enhanced"
    }
    
    population_2 = {
        "vulnerability_category": "URBAN_MIDDLE",
        "resource_availability": "FULL",
        "population_risks": ["GENERAL"],
        "population_size": 10000,
        "required_resources": 100
    }
    
    result_2 = penalty_system.calculate_penalty(decision_2, population_2)
    print("Scenario 2: Urban Area")
    print(json.dumps(result_2, indent=2))
    print()
    
    # Statistics
    stats = penalty_system.get_penalty_statistics()
    print("ðŸ“Š Penalty Statistics:")
    print(json.dumps(stats, indent=2))
