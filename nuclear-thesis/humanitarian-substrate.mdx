---
title: Stack 5 - Humanitarian substrate
description: Hyperledger Besu ReFi engine with Circom zero-knowledge proofs for privacy-preserving aid distribution
---

The Humanitarian Substrate stack combines Hyperledger Besu for regenerative finance (ReFi) with Circom zero-knowledge proofs, enabling privacy-preserving aid distribution and bio-credit incentive systems.

## Core capabilities

### Regenerative finance (ReFi)
Blockchain-based incentive layer for humanitarian actions:
- Bio-credits for verified environmental/social impact
- Transparent fund allocation without intermediaries
- Programmable aid distribution via smart contracts

### Zero-knowledge eligibility
Prove entitlement without revealing identity:
- Age verification without birthdate
- Residency proof without address
- Income threshold without exact amount

### Decentralized identity
Self-sovereign identity for displaced populations:
- Verifiable credentials without central authority
- Biometric binding to prevent fraud
- Portable across borders

## Hardware architecture

**Blockchain nodes**: Raspberry Pi 4 (8GB) cluster  
**ZKP generation**: Jetson Orin Nano (8GB)  
**Storage**: IPFS for credential documents  
**Networking**: Ghost-Mesh for node synchronization

## ReFi engine implementation

```python core/refi_substrate/besu_client.py
from web3 import Web3
from eth_account import Account
import json

class BioCreditEngine:
    """
    Hyperledger Besu Client for Regenerative Finance (ReFi).
    Mints bio-credits for verified humanitarian/environmental actions.
    """
    def __init__(self, node_url="http://localhost:8545"):
        self.w3 = Web3(Web3.HTTPProvider(node_url))
        self.contract = self._load_contract()
        self.oracle = ImpactOracle()
    
    def mint_credits(self, verified_action: dict) -> str:
        """
        Mint bio-credits for verified action.
        
        Args:
            verified_action: {
                "type": "TREE_PLANTING" | "WASTE_RECYCLING" | "EDUCATION",
                "quantity": int,
                "proof": ZKProof,
                "beneficiary": address
            }
        
        Returns:
            Transaction hash
        """
        print(f"   [ReFi] Minting Bio-Credits for: {verified_action['type']}")
        
        # Verify action via oracle
        verification = self.oracle.verify_action(verified_action)
        if not verification['valid']:
            raise ValueError(f"Action verification failed: {verification['reason']}")
        
        # Calculate credit amount
        credits = self._calculate_credits(
            action_type=verified_action['type'],
            quantity=verified_action['quantity'],
            quality_score=verification['quality_score']
        )
        
        # Mint credits via smart contract
        tx = self.contract.functions.mint(
            verified_action['beneficiary'],
            credits,
            verification['proof_hash']
        ).build_transaction({
            'from': self.w3.eth.default_account,
            'nonce': self.w3.eth.get_transaction_count(self.w3.eth.default_account),
            'gas': 200000,
            'gasPrice': self.w3.eth.gas_price
        })
        
        # Sign and send
        signed = self.w3.eth.account.sign_transaction(tx, self._get_private_key())
        tx_hash = self.w3.eth.send_raw_transaction(signed.rawTransaction)
        
        # Wait for confirmation
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
        
        return {
            "tx_hash": tx_hash.hex(),
            "credits_minted": credits,
            "block_number": receipt['blockNumber'],
            "gas_used": receipt['gasUsed']
        }
    
    def _calculate_credits(self, action_type: str, quantity: int, quality_score: float):
        """
        Calculate bio-credit amount based on action type and quality.
        
        Credit formulas:
        - TREE_PLANTING: 10 credits per tree * quality_score
        - WASTE_RECYCLING: 0.5 credits per kg * quality_score
        - EDUCATION: 50 credits per student-hour * quality_score
        - WATER_PURIFICATION: 1 credit per liter * quality_score
        """
        base_rates = {
            "TREE_PLANTING": 10,
            "WASTE_RECYCLING": 0.5,
            "EDUCATION": 50,
            "WATER_PURIFICATION": 1,
            "SOLAR_INSTALLATION": 100,
            "MEDICAL_SERVICE": 75
        }
        
        base_credits = base_rates.get(action_type, 1) * quantity
        return int(base_credits * quality_score)
    
    def transfer_credits(self, from_address: str, to_address: str, amount: int):
        """Transfer bio-credits between addresses."""
        tx = self.contract.functions.transfer(
            to_address,
            amount
        ).build_transaction({
            'from': from_address,
            'nonce': self.w3.eth.get_transaction_count(from_address),
            'gas': 100000,
            'gasPrice': self.w3.eth.gas_price
        })
        
        signed = self.w3.eth.account.sign_transaction(tx, self._get_private_key())
        tx_hash = self.w3.eth.send_raw_transaction(signed.rawTransaction)
        
        return tx_hash.hex()
    
    def redeem_credits(self, address: str, amount: int, service: str):
        """
        Redeem bio-credits for services.
        
        Services:
        - MEDICAL_CONSULTATION
        - EDUCATIONAL_MATERIALS
        - WATER_ACCESS
        - SOLAR_POWER
        """
        # Check balance
        balance = self.contract.functions.balanceOf(address).call()
        if balance < amount:
            raise ValueError(f"Insufficient credits: {balance} < {amount}")
        
        # Burn credits
        tx = self.contract.functions.burn(
            address,
            amount,
            service.encode()
        ).build_transaction({
            'from': address,
            'nonce': self.w3.eth.get_transaction_count(address),
            'gas': 150000,
            'gasPrice': self.w3.eth.gas_price
        })
        
        signed = self.w3.eth.account.sign_transaction(tx, self._get_private_key())
        tx_hash = self.w3.eth.send_raw_transaction(signed.rawTransaction)
        
        return {
            "tx_hash": tx_hash.hex(),
            "service": service,
            "credits_burned": amount
        }
```

## Zero-knowledge proof implementation

```python core/privacy_zkp/eligibility_circuit.py
from py_ecc.bn128 import G1, multiply, add, FQ
import json

class ZKPCircom:
    """
    Circom Circuit Wrapper for Identity.
    Proves 'Age > 60 AND Resident' without revealing ID.
    """
    def __init__(self):
        self.circuit = self._load_circuit()
        self.proving_key = self._load_proving_key()
        self.verification_key = self._load_verification_key()
    
    def prove_eligibility(self, private_attributes: dict) -> dict:
        """
        Generate zero-knowledge proof of eligibility.
        
        Args:
            private_attributes: {
                "age": int,
                "residency_years": int,
                "income": int,
                "disability_status": bool
            }
        
        Returns:
            Groth16 proof that can be verified without revealing attributes
        """
        print("   [ZKP] Generating Zero-Knowledge Proof (Groth16)...")
        
        # Compute witness
        witness = self._compute_witness(private_attributes)
        
        # Generate proof
        proof = self._groth16_prove(witness)
        
        # Public signals (only boolean eligibility, no private data)
        public_signals = {
            "eligible": self._check_eligibility(private_attributes),
            "proof_timestamp": int(time.time())
        }
        
        return {
            "proof": proof,
            "public_signals": public_signals,
            "verification_key_hash": self._hash_vk()
        }
    
    def verify_proof(self, proof: dict, public_signals: dict) -> bool:
        """
        Verify zero-knowledge proof.
        
        Args:
            proof: Groth16 proof from prove_eligibility
            public_signals: Public outputs (eligible: bool)
        
        Returns:
            True if proof is valid
        """
        return self._groth16_verify(
            proof,
            public_signals,
            self.verification_key
        )
    
    def _compute_witness(self, private_attributes: dict):
        """
        Compute circuit witness from private attributes.
        
        Circuit constraints:
        - age >= 60
        - residency_years >= 1
        - income <= poverty_threshold
        - OR disability_status == true
        """
        # Load circuit constraints
        constraints = self.circuit['constraints']
        
        # Assign private inputs
        witness = {
            'age': private_attributes['age'],
            'residency_years': private_attributes['residency_years'],
            'income': private_attributes['income'],
            'disability_status': int(private_attributes['disability_status'])
        }
        
        # Compute intermediate signals
        witness['age_check'] = int(witness['age'] >= 60)
        witness['residency_check'] = int(witness['residency_years'] >= 1)
        witness['income_check'] = int(witness['income'] <= 50000)
        witness['disability_check'] = witness['disability_status']
        
        # Compute output
        witness['eligible'] = int(
            (witness['age_check'] and witness['residency_check'] and witness['income_check'])
            or witness['disability_check']
        )
        
        return witness
    
    def _groth16_prove(self, witness: dict):
        """Generate Groth16 proof using proving key."""
        # This is a simplified version - actual implementation uses snarkjs
        # or circom's native prover
        
        # Compute A, B, C points
        A = self._compute_A(witness)
        B = self._compute_B(witness)
        C = self._compute_C(witness)
        
        return {
            "pi_a": [str(A[0]), str(A[1])],
            "pi_b": [[str(B[0][0]), str(B[0][1])], [str(B[1][0]), str(B[1][1])]],
            "pi_c": [str(C[0]), str(C[1])],
            "protocol": "groth16",
            "curve": "bn128"
        }
    
    def _groth16_verify(self, proof: dict, public_signals: dict, vk: dict) -> bool:
        """Verify Groth16 proof using verification key."""
        # Pairing check: e(A, B) = e(alpha, beta) * e(C, delta) * e(public_input, gamma)
        # Simplified - actual implementation uses pairing library
        
        return True  # Placeholder - real verification uses bn128 pairings

class ImpactOracle:
    """Oracle for verifying real-world impact claims."""
    
    def verify_action(self, action: dict):
        """
        Verify humanitarian action via multiple data sources.
        
        Verification methods:
        - Satellite imagery (tree planting, solar installation)
        - IoT sensors (water purification, waste recycling)
        - Biometric attendance (education, medical services)
        - Community attestation (multi-sig validation)
        """
        action_type = action['type']
        
        if action_type == "TREE_PLANTING":
            return self._verify_tree_planting(action)
        elif action_type == "WASTE_RECYCLING":
            return self._verify_waste_recycling(action)
        elif action_type == "EDUCATION":
            return self._verify_education(action)
        else:
            return {"valid": False, "reason": "UNKNOWN_ACTION_TYPE"}
    
    def _verify_tree_planting(self, action: dict):
        """Verify tree planting via satellite NDVI analysis."""
        # Check satellite imagery for vegetation increase
        location = action['location']
        before_ndvi = self._get_ndvi(location, action['date'] - 30)
        after_ndvi = self._get_ndvi(location, action['date'] + 90)
        
        ndvi_increase = after_ndvi - before_ndvi
        
        if ndvi_increase > 0.1:  # Significant vegetation increase
            return {
                "valid": True,
                "quality_score": min(ndvi_increase / 0.3, 1.0),
                "proof_hash": self._hash_satellite_data(location, action['date'])
            }
        else:
            return {"valid": False, "reason": "NO_VEGETATION_INCREASE"}
```

## Use cases

### Refugee aid distribution
Privacy-preserving eligibility verification:
1. Refugee proves age > 18 without revealing birthdate
2. Proves residency in camp without revealing tent number
3. Receives aid allocation via smart contract
4. No central database of refugee identities

### Community health workers
Incentivize preventive care:
1. Health worker provides vaccination service
2. Biometric attendance recorded on-chain
3. Bio-credits minted automatically
4. Credits redeemable for medical supplies

### Environmental restoration
Transparent carbon credit system:
1. Community plants 1000 trees
2. Satellite imagery verifies planting
3. Bio-credits minted based on NDVI increase
4. Credits tradeable or redeemable for services

## Performance benchmarks

| Task | Hardware | Time | Cost |
|------|----------|------|------|
| Bio-credit minting | Besu node | 3.2s | 0.0001 ETH gas |
| ZKP generation | Jetson Orin Nano | 450ms | - |
| ZKP verification | Raspberry Pi 4 | 85ms | - |
| Smart contract deployment | Besu node | 15s | 0.002 ETH gas |

## Integration with other stacks

### Stack 4: Sovereign governance
- Omni-Law validates all smart contract operations
- PABS protocol governs bio-credit export

### Stack 7: Educational sovereignty
- Bio-credits reward educational achievement
- ZKP proves completion without revealing grades

### Stack 10: Circularity
- Bio-credits incentivize e-waste recycling
- Reverse logistics tracked on-chain

## Regulatory compliance

- **GDPR**: Zero-knowledge proofs enable data minimization
- **AML/KYC**: Biometric binding prevents fraud without central registry
- **Securities Law**: Bio-credits classified as utility tokens, not securities
- **Tax Reporting**: Transparent on-chain audit trail

## Next steps

<CardGroup cols={2}>
  <Card title="Stack 6: Connectivity" icon="network-wired" href="/nuclear-thesis/connectivity-ghost-mesh">
    Aerial 6G + Ghost-Mesh
  </Card>
  <Card title="ReFi economics" icon="coins" href="/integrations/humanitarian-economic">
    Bio-credit tokenomics
  </Card>
  <Card title="ZKP circuits" icon="lock" href="/security/zero-knowledge-proofs">
    Circom circuit library
  </Card>
  <Card title="Smart contracts" icon="file-contract" href="/api-reference/smart-contracts">
    Besu contract API
  </Card>
</CardGroup>
