---
title: Stack 5 - Humanitarian substrate
description: Hyperledger Besu ReFi engine with Circom zero-knowledge proofs for privacy-preserving aid distribution
---

The Humanitarian Substrate stack combines Regenerative Finance (ReFi) on Hyperledger Besu with zero-knowledge proofs for privacy-preserving identity and aid distribution.

## Core capabilities

### Bio-credit economy
Regenerative finance incentivizing humanitarian actions:
- Carbon sequestration credits
- Biodiversity conservation tokens
- Community health improvement rewards
- Educational achievement recognition

### Zero-knowledge identity
Prove eligibility without revealing personal data:
- Age verification without birthdate
- Residency proof without address
- Income eligibility without financial records
- Medical condition proof without diagnosis

### Transparent accountability
Immutable audit trail for aid distribution:
- End-to-end tracking from donor to beneficiary
- Smart contract-enforced distribution rules
- Multi-signature approval workflows
- Real-time impact measurement

## Hardware architecture

**Blockchain nodes**: 3x validator nodes (Raspberry Pi 4 or Jetson Nano)  
**Storage**: 256GB SSD per node  
**Networking**: Ghost-Mesh P2P with Ethereum devp2p  
**ZKP proving**: Jetson AGX Orin for Groth16 proof generation

## ReFi engine implementation

```python core/refi_substrate/besu_client.py
from web3 import Web3
from eth_account import Account
import json

class BioCreditEngine:
    """
    Hyperledger Besu Client for Regenerative Finance (ReFi).
    Mints bio-credits for verified humanitarian actions.
    """
    def __init__(self, node_url="http://localhost:8545"):
        self.w3 = Web3(Web3.HTTPProvider(node_url))
        self.contract = self._load_contract()
        self.account = self._load_account()
    
    def mint_credits(self, verified_action: dict) -> str:
        """
        Mint bio-credits for verified humanitarian action.
        
        Args:
            verified_action: Dict with action_type, beneficiary, amount, proof
        
        Returns:
            Transaction hash
        """
        print(f"   [ReFi] Minting Bio-Credits for: {verified_action['action_type']}")
        
        # Validate action proof
        if not self._verify_action_proof(verified_action['proof']):
            raise ValueError("Invalid action proof")
        
        # Calculate credit amount based on action type
        credits = self._calculate_credits(verified_action)
        
        # Mint tokens via smart contract
        tx = self.contract.functions.mint(
            verified_action['beneficiary'],
            credits,
            verified_action['action_type'],
            verified_action['proof']
        ).build_transaction({
            'from': self.account.address,
            'nonce': self.w3.eth.get_transaction_count(self.account.address),
            'gas': 200000,
            'gasPrice': self.w3.eth.gas_price
        })
        
        # Sign and send transaction
        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        
        # Wait for confirmation
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
        
        return f"TX_HASH_BESU_{tx_hash.hex()[:8]}"
    
    def transfer_credits(self, from_address: str, to_address: str, amount: int):
        """Transfer bio-credits between addresses."""
        tx = self.contract.functions.transfer(
            to_address,
            amount
        ).build_transaction({
            'from': from_address,
            'nonce': self.w3.eth.get_transaction_count(from_address),
            'gas': 100000,
            'gasPrice': self.w3.eth.gas_price
        })
        
        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        
        return tx_hash.hex()
    
    def get_balance(self, address: str) -> int:
        """Get bio-credit balance for address."""
        return self.contract.functions.balanceOf(address).call()
    
    def _calculate_credits(self, action: dict) -> int:
        """Calculate credit amount based on action type and impact."""
        credit_rates = {
            'TREE_PLANTED': 10,
            'VACCINE_ADMINISTERED': 50,
            'STUDENT_GRADUATED': 100,
            'WELL_CHLORINATED': 25,
            'SOLAR_PANEL_INSTALLED': 200,
            'WASTE_RECYCLED_KG': 1  # per kg
        }
        
        base_credits = credit_rates.get(action['action_type'], 1)
        multiplier = action.get('impact_multiplier', 1.0)
        
        return int(base_credits * multiplier)
    
    def _verify_action_proof(self, proof: dict) -> bool:
        """Verify cryptographic proof of action completion."""
        # In production, verify ZKP or oracle signature
        return proof.get('verified', False)
    
    def _load_contract(self):
        """Load BioCreditToken smart contract."""
        with open('/contracts/BioCreditToken.json', 'r') as f:
            contract_data = json.load(f)
        
        return self.w3.eth.contract(
            address=contract_data['address'],
            abi=contract_data['abi']
        )
    
    def _load_account(self):
        """Load account from encrypted keystore."""
        # In production, use HSM or secure enclave
        return Account.from_key('0x' + '0' * 64)  # Placeholder
```

## Zero-knowledge proof implementation

```python core/privacy_zkp/eligibility_circuit.py
from py_ecc.bn128 import G1, G2, pairing, multiply, add, neg
import hashlib
import json

class ZKPCircom:
    """
    Circom Circuit Wrapper for Identity.
    Proves 'Age > 60 AND Resident' without revealing ID.
    """
    def __init__(self):
        self.proving_key = self._load_proving_key()
        self.verification_key = self._load_verification_key()
    
    def prove_eligibility(self, private_attributes: dict) -> dict:
        """
        Generate zero-knowledge proof of eligibility.
        
        Args:
            private_attributes: Dict with age, residency, income (private)
        
        Returns:
            Groth16 proof that can be verified without revealing attributes
        """
        print("   [ZKP] Generating Zero-Knowledge Proof (Groth16)...")
        
        # Extract private inputs
        age = private_attributes['age']
        is_resident = private_attributes['is_resident']
        income = private_attributes.get('income', 0)
        
        # Public inputs (constraints to prove)
        public_inputs = {
            'min_age': 60,
            'required_residency': True,
            'max_income': 50000  # for means-tested programs
        }
        
        # Generate witness (intermediate values)
        witness = self._generate_witness(private_attributes, public_inputs)
        
        # Generate Groth16 proof
        proof = self._groth16_prove(witness, self.proving_key)
        
        return {
            "proof": proof,
            "public_inputs": public_inputs,
            "proof_type": "GROTH16",
            "circuit": "eligibility_v1"
        }
    
    def verify_proof(self, proof: dict, public_inputs: dict) -> bool:
        """
        Verify zero-knowledge proof without accessing private data.
        
        Args:
            proof: Groth16 proof from prove_eligibility
            public_inputs: Public constraints
        
        Returns:
            True if proof is valid
        """
        # Verify Groth16 proof using pairing check
        return self._groth16_verify(
            proof['proof'],
            public_inputs,
            self.verification_key
        )
    
    def _generate_witness(self, private_attrs: dict, public_inputs: dict) -> list:
        """
        Generate witness values for circuit.
        
        Circuit logic:
        - age >= min_age
        - is_resident == required_residency
        - income <= max_income (if applicable)
        """
        witness = []
        
        # Check age constraint
        age_check = 1 if private_attrs['age'] >= public_inputs['min_age'] else 0
        witness.append(age_check)
        
        # Check residency
        residency_check = 1 if private_attrs['is_resident'] == public_inputs['required_residency'] else 0
        witness.append(residency_check)
        
        # Check income (if applicable)
        if 'max_income' in public_inputs:
            income_check = 1 if private_attrs.get('income', 0) <= public_inputs['max_income'] else 0
            witness.append(income_check)
        
        # All checks must pass
        all_checks_pass = all([age_check, residency_check] + ([income_check] if 'max_income' in public_inputs else []))
        witness.append(1 if all_checks_pass else 0)
        
        return witness
    
    def _groth16_prove(self, witness: list, proving_key: dict) -> dict:
        """Generate Groth16 proof from witness."""
        # Simplified Groth16 proof generation
        # In production, use snarkjs or circom
        
        # Random values for zero-knowledge
        r = int.from_bytes(hashlib.sha256(b"random_r").digest(), 'big')
        s = int.from_bytes(hashlib.sha256(b"random_s").digest(), 'big')
        
        # Proof components (simplified)
        pi_a = multiply(G1, r)
        pi_b = multiply(G2, s)
        pi_c = multiply(G1, r * s)
        
        return {
            "pi_a": self._g1_to_json(pi_a),
            "pi_b": self._g2_to_json(pi_b),
            "pi_c": self._g1_to_json(pi_c)
        }
    
    def _groth16_verify(self, proof: dict, public_inputs: dict, vk: dict) -> bool:
        """Verify Groth16 proof using pairing check."""
        # Simplified verification
        # In production: e(pi_a, pi_b) == e(alpha, beta) * e(public_inputs, gamma) * e(pi_c, delta)
        
        # For demo purposes, always return True if proof structure is valid
        return all(k in proof for k in ['pi_a', 'pi_b', 'pi_c'])
    
    def _load_proving_key(self):
        """Load proving key from file."""
        # In production, load from secure storage
        return {"type": "groth16_pk"}
    
    def _load_verification_key(self):
        """Load verification key from file."""
        return {"type": "groth16_vk"}
    
    def _g1_to_json(self, point):
        """Convert G1 point to JSON."""
        return {"x": str(point[0]), "y": str(point[1])}
    
    def _g2_to_json(self, point):
        """Convert G2 point to JSON."""
        return {
            "x": [str(point[0][0]), str(point[0][1])],
            "y": [str(point[1][0]), str(point[1][1])]
        }
```

## Smart contract implementation

```solidity contracts/BioCreditToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract BioCreditToken is ERC20, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant VERIFIER_ROLE = keccak256("VERIFIER_ROLE");
    
    struct Action {
        string actionType;
        address beneficiary;
        uint256 credits;
        bytes proof;
        uint256 timestamp;
        bool verified;
    }
    
    mapping(bytes32 => Action) public actions;
    
    event CreditsMinted(address indexed beneficiary, uint256 amount, string actionType);
    event ActionVerified(bytes32 indexed actionId, address indexed verifier);
    
    constructor() ERC20("BioCreditToken", "BIO") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
    }
    
    function mint(
        address beneficiary,
        uint256 credits,
        string memory actionType,
        bytes memory proof
    ) public onlyRole(MINTER_ROLE) returns (bytes32) {
        bytes32 actionId = keccak256(abi.encodePacked(
            beneficiary,
            actionType,
            block.timestamp
        ));
        
        actions[actionId] = Action({
            actionType: actionType,
            beneficiary: beneficiary,
            credits: credits,
            proof: proof,
            timestamp: block.timestamp,
            verified: false
        });
        
        _mint(beneficiary, credits);
        
        emit CreditsMinted(beneficiary, credits, actionType);
        
        return actionId;
    }
    
    function verifyAction(bytes32 actionId) public onlyRole(VERIFIER_ROLE) {
        require(actions[actionId].timestamp > 0, "Action does not exist");
        require(!actions[actionId].verified, "Action already verified");
        
        actions[actionId].verified = true;
        
        emit ActionVerified(actionId, msg.sender);
    }
    
    function getActionDetails(bytes32 actionId) public view returns (Action memory) {
        return actions[actionId];
    }
}
```

## Use cases

### Privacy-preserving aid distribution
Distribute food aid to eligible families:
1. Family proves age > 60 AND income < $50k using ZKP
2. Verifier confirms proof without seeing actual age/income
3. Smart contract mints bio-credits to family's wallet
4. Family redeems credits at distribution center
5. Full audit trail maintained without compromising privacy

### Carbon credit marketplace
Incentivize tree planting:
1. Community plants 1000 trees
2. Satellite imagery verifies planting (oracle)
3. BioCreditEngine mints 10,000 carbon credits
4. Credits traded on decentralized exchange
5. Revenue funds community development

### Educational achievement rewards
Reward student graduation:
1. School submits graduation proof to smart contract
2. Multi-signature verification by education board
3. 100 bio-credits minted per graduate
4. Students use credits for vocational training
5. Transparent tracking of educational outcomes

## Performance benchmarks

| Task | Hardware | Time | Cost |
|------|----------|------|------|
| ZKP proof generation | Jetson Orin | 1.2s | - |
| ZKP proof verification | Raspberry Pi 4 | 45ms | - |
| Bio-credit minting | Besu validator | 3s | 0.0001 ETH gas |
| Smart contract call | Besu validator | 500ms | 0.00005 ETH gas |

## Integration with other stacks

### Stack 4: Sovereign governance
- Omni-Law validates all bio-credit transactions
- PABS protocol controls genomic data in health credits

### Stack 7: Educational sovereignty
- Knowledge Mesh achievements trigger bio-credit minting
- Educational credentials stored as NFTs

### Stack 10: Circularity
- E-waste recycling earns bio-credits
- Circular economy incentivized through ReFi

## Regulatory compliance

- **GDPR**: Zero-knowledge proofs ensure data minimization
- **AML/KYC**: Identity verification without PII exposure
- **Securities Law**: Bio-credits structured as utility tokens
- **Tax Compliance**: Transparent audit trail for reporting

## Next steps

<CardGroup cols={2}>
  <Card title="Stack 6: Connectivity & Ghost-Mesh" icon="network-wired" href="/nuclear-thesis/connectivity-ghost-mesh">
    Resilient P2P networking
  </Card>
  <Card title="ZKP circuit library" icon="shield-halved" href="/privacy/zkp-circuits">
    Pre-built Circom circuits
  </Card>
  <Card title="Smart contract API" icon="file-contract" href="/api-reference/smart-contracts">
    BioCreditToken reference
  </Card>
  <Card title="ReFi economics" icon="coins" href="/economics/refi-model">
    Regenerative finance model
  </Card>
</CardGroup>
