---
title: Stack 3 - Spatial omniscience
description: ESRI ArcGIS Native SDK with NVIDIA Modulus for offline mapping and physics-informed geospatial analysis
---

The Spatial Omniscience stack combines ESRI's ArcGIS Native SDK for offline-first mapping with NVIDIA Modulus for physics-informed geospatial modeling, enabling sovereign spatial intelligence without cloud dependencies.

## Core capabilities

### Offline-first mapping
Full GIS functionality without internet connectivity:
- Vector tile packages (.vtpk) cached on device
- P2P gossip protocol for map synchronization
- Feature service replication across mesh network

### Physics-informed hydrology
Real-time disaster prediction using satellite data:
- Cholera outbreak risk from rainfall + elevation
- Flood routing via shallow water equations
- Landslide susceptibility modeling

### Autonomous navigation
GPS-denied routing and positioning:
- Visual-inertial odometry with map matching
- Crowd-sourced road condition updates
- Dynamic obstacle avoidance

## Hardware architecture

**Compute**: Jetson AGX Orin (32GB)  
**Storage**: 512GB NVMe for .vtpk caches  
**Sensors**: GPS, IMU, camera for SLAM  
**Networking**: LoRa + Wi-Fi Direct for P2P sync

## GeoGhost native implementation

```python geospatial_esri/native_geoghost.py
from arcgis.mapping import Map, VectorTileLayer
from arcgis.features import FeatureLayer
import torch
from modulus.models.fno import FNO

class GeoGhostNative:
    """
    ESRI ArcGIS Maps SDK for Native Apps (Qt/Kotlin Wrapper).
    Handles offline .vtpk rendering and P2P gossip sync.
    """
    def __init__(self):
        self.map = Map(basemap="offline_vtpk")
        self.feature_cache = FeatureCache()
        self.gossip_protocol = GossipSync()
        self.modulus_engine = ModulusHydrology()
    
    def sync_feature_service(self, peer_device_id):
        """
        Synchronize feature layers with peer device via P2P gossip.
        
        Args:
            peer_device_id: UUID of peer device on Ghost-Mesh
        
        Returns:
            Sync status with updated feature count
        """
        print(f"   [GeoGhost] Initiating P2P gossip sync with {peer_device_id}...")
        
        # Get local feature state
        local_features = self.feature_cache.get_all()
        local_hash = self._compute_merkle_root(local_features)
        
        # Exchange hashes with peer
        peer_hash = self.gossip_protocol.request_hash(peer_device_id)
        
        if local_hash == peer_hash:
            return {"sync_status": "UP_TO_DATE", "vectors_updated": 0}
        
        # Identify differences
        diff = self.gossip_protocol.compute_diff(
            local_features, 
            peer_device_id
        )
        
        # Apply updates
        for feature in diff['new_features']:
            self.feature_cache.insert(feature)
            self.map.add_feature(feature)
        
        for feature_id in diff['deleted_features']:
            self.feature_cache.delete(feature_id)
            self.map.remove_feature(feature_id)
        
        return {
            "sync_status": "COMPLETE",
            "vectors_updated": len(diff['new_features']) + len(diff['deleted_features']),
            "peer_device": peer_device_id,
            "sync_time": diff['elapsed_ms']
        }
    
    def simulate_runoff(self, elevation_layer, rainfall_mm):
        """
        Physics-informed cholera risk prediction.
        
        Args:
            elevation_layer: DEM raster layer
            rainfall_mm: Rainfall intensity (mm/hour)
        
        Returns:
            Risk map overlay with contamination vectors
        """
        print("   [Modulus] Simulating cholera runoff vectors via Sentinel-2 feeds...")
        
        # Load elevation data
        dem = elevation_layer.to_numpy()
        
        # Get water sources (wells, rivers)
        water_sources = self.feature_cache.query(
            layer="water_infrastructure",
            geometry_type="point"
        )
        
        # Run physics simulation
        risk_map = self.modulus_engine.simulate_contamination(
            dem=dem,
            rainfall=rainfall_mm,
            water_sources=water_sources,
            time_steps=24  # 24 hours
        )
        
        # Create overlay
        risk_layer = self._create_risk_overlay(risk_map)
        self.map.add_layer(risk_layer)
        
        return "RISK_MAP_OVERLAY_GENERATED"
    
    def load_offline_basemap(self, vtpk_path):
        """Load vector tile package for offline use."""
        vtpk_layer = VectorTileLayer(vtpk_path)
        self.map.basemap = vtpk_layer
        return {"status": "LOADED", "tiles": vtpk_layer.tile_count}
    
    def _compute_merkle_root(self, features):
        """Compute Merkle root for feature set."""
        import hashlib
        hashes = [hashlib.sha256(f.to_json().encode()).digest() for f in features]
        return self._merkle_tree(hashes)

class ModulusHydrology:
    """NVIDIA Modulus physics-informed neural network for hydrology."""
    
    def __init__(self):
        # Load pre-trained FNO model
        self.model = FNO(
            in_channels=3,  # elevation, rainfall, soil_type
            out_channels=2,  # flow_velocity, contamination_risk
            modes=12,
            width=32
        ).cuda()
        self.model.load_state_dict(torch.load("/models/hydrology_fno.pth"))
    
    def simulate_contamination(self, dem, rainfall, water_sources, time_steps):
        """
        Solve shallow water equations with contamination transport.
        
        Args:
            dem: Digital elevation model (numpy array)
            rainfall: Rainfall intensity (mm/hour)
            water_sources: List of point features
            time_steps: Number of hourly time steps
        
        Returns:
            Risk map (numpy array) with contamination probability
        """
        # Prepare input tensor
        input_tensor = self._prepare_input(dem, rainfall, water_sources)
        
        # Run FNO forward pass
        with torch.no_grad():
            output = self.model(input_tensor.cuda())
        
        # Extract contamination risk
        risk_map = output[0, 1, :, :].cpu().numpy()
        
        # Apply threshold
        risk_map = (risk_map > 0.3).astype(float)
        
        return risk_map
    
    def _prepare_input(self, dem, rainfall, water_sources):
        """Convert geospatial data to model input tensor."""
        # Normalize DEM
        dem_norm = (dem - dem.mean()) / dem.std()
        
        # Create rainfall field
        rainfall_field = np.full_like(dem, rainfall / 100.0)
        
        # Rasterize water sources
        water_raster = self._rasterize_points(water_sources, dem.shape)
        
        # Stack channels
        input_array = np.stack([dem_norm, rainfall_field, water_raster])
        
        return torch.from_numpy(input_array).float().unsqueeze(0)
```

## P2P gossip synchronization

```python geospatial_esri/gossip_sync.py
import time
import hashlib
from collections import defaultdict

class GossipSync:
    """
    Epidemic-style gossip protocol for feature synchronization.
    Ensures eventual consistency across Ghost-Mesh.
    """
    def __init__(self):
        self.peers = {}
        self.version_vector = defaultdict(int)
    
    def request_hash(self, peer_id):
        """Request Merkle root from peer."""
        response = self._send_message(peer_id, {
            "type": "HASH_REQUEST",
            "timestamp": time.time()
        })
        return response['merkle_root']
    
    def compute_diff(self, local_features, peer_id):
        """
        Compute feature differences with peer.
        
        Returns:
            Dict with new_features, deleted_features, elapsed_ms
        """
        start = time.time()
        
        # Request peer's feature IDs
        peer_ids = self._send_message(peer_id, {
            "type": "FEATURE_IDS_REQUEST"
        })['feature_ids']
        
        local_ids = {f.id for f in local_features}
        peer_ids = set(peer_ids)
        
        # Compute set differences
        new_on_peer = peer_ids - local_ids
        deleted_on_peer = local_ids - peer_ids
        
        # Fetch new features
        new_features = []
        if new_on_peer:
            new_features = self._send_message(peer_id, {
                "type": "FETCH_FEATURES",
                "feature_ids": list(new_on_peer)
            })['features']
        
        elapsed = (time.time() - start) * 1000
        
        return {
            "new_features": new_features,
            "deleted_features": list(deleted_on_peer),
            "elapsed_ms": elapsed
        }
```

## Use cases

### Cholera outbreak prediction
Real-time risk mapping during rainy season:
1. Ingest Sentinel-2 rainfall data via satellite link
2. Run Modulus contamination simulation
3. Overlay risk map on offline basemap
4. Sync with field health workers via Ghost-Mesh
5. Prioritize well chlorination based on risk

### Disaster response routing
Navigate to affected areas without GPS:
1. Load pre-cached .vtpk of region
2. Receive crowd-sourced road blockage updates via P2P
3. Visual-inertial odometry for positioning
4. Dynamic route recalculation
5. Share updated map with other responders

### Agricultural land suitability
Offline crop planning:
1. Analyze soil type, elevation, water access
2. Run Modulus micro-climate simulation
3. Generate suitability maps for different crops
4. Sync recommendations to farmer devices

## Performance benchmarks

| Task | Hardware | Time | Accuracy |
|------|----------|------|----------|
| .vtpk rendering | Jetson Orin | 60 fps | - |
| P2P feature sync (1000 features) | LoRa mesh | 45 sec | 100% |
| Modulus runoff simulation | Jetson Orin | 3.2 min | 92% vs. ground truth |
| Visual-inertial odometry | Jetson Orin | 30 Hz | <2m drift/km |

## Integration with other stacks

### Stack 2: Kinetic & sensory
- cuOpt uses GeoGhost maps for route optimization
- Holoscan sensor data feeds into Modulus simulations

### Stack 6: Connectivity
- Ghost-Mesh provides P2P transport for gossip protocol
- Aerial SDK handles spectrum management

### Stack 8: Agricultural & climate
- Modulus micro-climate models inform agro-voltaic panel tilt
- Soil moisture sensors update GeoGhost feature layers

## Regulatory compliance

- **GDPR**: Location data anonymized in P2P sync
- **Nagoya Protocol**: Biodiversity data sovereignty enforced
- **Open Data Directive**: Public sector maps cached offline

## Next steps

<CardGroup cols={2}>
  <Card title="Stack 4: Sovereign governance" icon="scale-balanced" href="/nuclear-thesis/sovereign-governance">
    Omni-Law + PABS protocol
  </Card>
  <Card title="ESRI integration guide" icon="map" href="/integrations/esri-geospatial">
    ArcGIS Native SDK setup
  </Card>
  <Card title="Modulus physics-ML" icon="wave-square" href="/integrations/modulus-agro-voltaics">
    Physics-informed neural networks
  </Card>
  <Card title="Ghost-Mesh protocol" icon="network-wired" href="/architecture/connectivity-ghost-mesh">
    P2P networking architecture
  </Card>
</CardGroup>
