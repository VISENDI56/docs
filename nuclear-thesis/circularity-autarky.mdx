---
title: Stack 10 - Circularity & autarky
description: cuOpt-powered reverse logistics for urban mining and zero-waste circular economy
---

The Circularity & Autarky stack uses NVIDIA cuOpt for reverse logistics optimization, enabling urban mining of e-waste and creating closed-loop supply chains that eliminate waste while building economic self-sufficiency.

## Core capabilities

### Reverse logistics
Optimize collection and processing of waste materials:
- E-waste harvesting routes
- Component recovery prioritization
- Repair-preneur network coordination
- Material flow optimization

### Urban mining
Extract valuable materials from waste:
- Precious metal recovery from electronics
- Battery material reclamation
- Plastic sorting and recycling
- Rare earth element extraction

### Circular economy
Close material loops for zero waste:
- Product lifecycle tracking on blockchain
- Design for disassembly guidelines
- Material passport system
- Remanufacturing coordination

## Hardware architecture

**Compute**: Jetson AGX Orin for edge routing  
**Sensors**: RFID readers, computer vision for sorting  
**Actuators**: Robotic disassembly arms  
**Storage**: Blockchain for material provenance

## Circular router implementation

```python core/circular_economy/reverse_logistics.py
from cuopt import routing
import numpy as np

class CircularRouter:
    """
    cuOpt for Reverse Logistics (Urban Mining).
    Routes E-Waste to harvesting benches.
    """
    def __init__(self):
        self.solver = routing.Solver()
        self.material_db = MaterialDatabase()
        self.repair_network = RepairPreneurNetwork()
        self.blockchain = MaterialPassport()
    
    def route_harvest(self, waste_type: str, location: dict) -> dict:
        """
        Optimize routing for waste collection and processing.
        
        Args:
            waste_type: Type of waste (e-waste, plastic, metal, etc.)
            location: Collection point coordinates
        
        Returns:
            Optimized route with processing assignments
        """
        print(f"   [Circular] Routing {waste_type} to nearest Repair-Preneur...")
        
        # Get collection points
        collection_points = self._get_collection_points(waste_type)
        
        # Get processing facilities
        facilities = self._get_processing_facilities(waste_type)
        
        # Assess material value
        material_value = self._assess_material_value(waste_type, collection_points)
        
        # Build VRP problem
        problem = self._build_reverse_vrp(
            collection_points=collection_points,
            facilities=facilities,
            material_value=material_value
        )
        
        # Solve with cuOpt
        solution = self.solver.solve(
            problem,
            time_limit=10.0,
            backend="GPU_HEURISTIC"
        )
        
        # Assign to repair-preneurs
        assignments = self._assign_to_repair_preneurs(solution, waste_type)
        
        # Record on blockchain
        self._record_material_flow(assignments)
        
        return {
            "route": solution.routes,
            "assignments": assignments,
            "total_distance": solution.total_distance,
            "estimated_value": self._compute_recovery_value(assignments),
            "co2_saved": self._compute_co2_savings(assignments)
        }
    
    def _build_reverse_vrp(self, collection_points: list, 
                          facilities: list, 
                          material_value: dict) -> routing.Problem:
        """
        Build reverse logistics VRP problem.
        
        Objectives:
        1. Minimize collection distance
        2. Maximize material value recovered
        3. Balance load across facilities
        """
        problem = routing.Problem()
        
        # Add collection points as pickups
        for point in collection_points:
            problem.add_location(
                lat=point['lat'],
                lon=point['lon'],
                demand=point['quantity'],
                value=material_value.get(point['id'], 0),
                time_window=point.get('time_window'),
                location_type="PICKUP"
            )
        
        # Add processing facilities as dropoffs
        for facility in facilities:
            problem.add_location(
                lat=facility['lat'],
                lon=facility['lon'],
                capacity=facility['capacity'],
                processing_cost=facility['cost_per_kg'],
                location_type="DROPOFF"
            )
        
        # Add vehicles (collection trucks)
        for vehicle in self._get_available_vehicles():
            problem.add_vehicle(
                capacity=vehicle['capacity'],
                start_location=vehicle['depot'],
                end_location=vehicle['depot'],
                cost_per_km=vehicle['cost_per_km']
            )
        
        # Add constraints
        problem.add_constraint(
            routing.CapacityConstraint()
        )
        
        problem.add_constraint(
            routing.TimeWindowConstraint()
        )
        
        # Multi-objective: minimize cost, maximize value
        problem.set_objective(
            routing.MultiObjective([
                ("minimize", "total_distance", 0.4),
                ("maximize", "total_value", 0.6)
            ])
        )
        
        return problem
    
    def _assess_material_value(self, waste_type: str, 
                               collection_points: list) -> dict:
        """
        Assess material value for prioritization.
        
        Value factors:
        - Precious metal content (gold, silver, platinum)
        - Rare earth elements
        - Reusable components
        - Material purity
        """
        values = {}
        
        for point in collection_points:
            # Get material composition
            composition = self.material_db.get_composition(
                waste_type,
                point.get('product_type')
            )
            
            # Compute value
            value = 0
            
            # Precious metals
            value += composition.get('gold_g', 0) * 60  # $60/g
            value += composition.get('silver_g', 0) * 0.8  # $0.8/g
            value += composition.get('platinum_g', 0) * 30  # $30/g
            
            # Rare earths
            value += composition.get('neodymium_g', 0) * 0.15  # $0.15/g
            value += composition.get('dysprosium_g', 0) * 0.50  # $0.50/g
            
            # Reusable components
            value += composition.get('reusable_components', 0) * 5  # $5/component
            
            # Recyclable materials
            value += composition.get('copper_kg', 0) * 8  # $8/kg
            value += composition.get('aluminum_kg', 0) * 2  # $2/kg
            
            values[point['id']] = value
        
        return values
    
    def _assign_to_repair_preneurs(self, solution: routing.Solution, 
                                   waste_type: str) -> list:
        """
        Assign collected materials to repair-preneurs.
        
        Repair-preneurs are local entrepreneurs who:
        - Repair and refurbish electronics
        - Harvest components for reuse
        - Perform initial material sorting
        """
        assignments = []
        
        for route in solution.routes:
            for stop in route.stops:
                if stop.location_type == "PICKUP":
                    # Find nearest repair-preneur with capacity
                    repair_preneur = self.repair_network.find_nearest(
                        location=stop.location,
                        waste_type=waste_type,
                        quantity=stop.quantity
                    )
                    
                    if repair_preneur:
                        assignments.append({
                            "collection_point": stop.location,
                            "repair_preneur": repair_preneur['id'],
                            "quantity": stop.quantity,
                            "estimated_value": stop.value,
                            "processing_time": repair_preneur['processing_time']
                        })
        
        return assignments
    
    def _record_material_flow(self, assignments: list):
        """Record material flow on blockchain for traceability."""
        for assignment in assignments:
            self.blockchain.record_transfer({
                "from": assignment['collection_point'],
                "to": assignment['repair_preneur'],
                "material_type": assignment.get('material_type'),
                "quantity": assignment['quantity'],
                "timestamp": time.time(),
                "value": assignment['estimated_value']
            })
    
    def _compute_recovery_value(self, assignments: list) -> float:
        """Compute total value of materials recovered."""
        return sum(a['estimated_value'] for a in assignments)
    
    def _compute_co2_savings(self, assignments: list) -> float:
        """
        Compute CO2 savings from recycling vs. virgin material production.
        
        CO2 savings (kg CO2 per kg material):
        - Aluminum: 9 kg CO2/kg
        - Copper: 2.5 kg CO2/kg
        - Steel: 1.5 kg CO2/kg
        - Plastic: 2.0 kg CO2/kg
        """
        co2_savings = 0
        
        for assignment in assignments:
            composition = self.material_db.get_composition(
                assignment.get('material_type'),
                assignment.get('product_type')
            )
            
            co2_savings += composition.get('aluminum_kg', 0) * 9
            co2_savings += composition.get('copper_kg', 0) * 2.5
            co2_savings += composition.get('steel_kg', 0) * 1.5
            co2_savings += composition.get('plastic_kg', 0) * 2.0
        
        return co2_savings

class MaterialDatabase:
    """
    Database of material compositions for different product types.
    """
    def __init__(self):
        self.compositions = self._load_compositions()
    
    def get_composition(self, waste_type: str, product_type: str = None) -> dict:
        """
        Get material composition for waste type.
        
        Args:
            waste_type: e-waste, plastic, metal, etc.
            product_type: smartphone, laptop, etc.
        
        Returns:
            Material composition with quantities
        """
        if product_type:
            key = f"{waste_type}_{product_type}"
        else:
            key = waste_type
        
        return self.compositions.get(key, {})
    
    def _load_compositions(self):
        """
        Load material composition database.
        
        Example compositions:
        - Smartphone: 0.034g gold, 0.34g silver, 16g copper, 40g plastic
        - Laptop: 0.2g gold, 1g silver, 200g copper, 2kg plastic
        - LED bulb: 0.5g rare earths, 50g aluminum, 20g plastic
        """
        return {
            "e-waste_smartphone": {
                "gold_g": 0.034,
                "silver_g": 0.34,
                "copper_kg": 0.016,
                "aluminum_kg": 0.025,
                "plastic_kg": 0.040,
                "rare_earths_g": 0.5,
                "reusable_components": 3
            },
            "e-waste_laptop": {
                "gold_g": 0.2,
                "silver_g": 1.0,
                "copper_kg": 0.2,
                "aluminum_kg": 0.5,
                "plastic_kg": 2.0,
                "rare_earths_g": 2.0,
                "reusable_components": 10
            },
            "e-waste_led_bulb": {
                "rare_earths_g": 0.5,
                "aluminum_kg": 0.05,
                "plastic_kg": 0.02,
                "reusable_components": 0
            }
        }

class MaterialPassport:
    """
    Blockchain-based material passport for circular economy.
    """
    def __init__(self):
        self.blockchain = HyperledgerClient()
    
    def record_transfer(self, transfer: dict):
        """Record material transfer on blockchain."""
        tx = self.blockchain.submit_transaction(
            chaincode="material_passport",
            function="recordTransfer",
            args=[
                transfer['from'],
                transfer['to'],
                transfer['material_type'],
                str(transfer['quantity']),
                str(transfer['timestamp']),
                str(transfer['value'])
            ]
        )
        return tx['transaction_id']
    
    def get_material_history(self, material_id: str) -> list:
        """Get complete history of material from production to recycling."""
        history = self.blockchain.query(
            chaincode="material_passport",
            function="getMaterialHistory",
            args=[material_id]
        )
        return history
```

## Robotic disassembly

```python core/circular_economy/robotic_disassembly.py
class RoboticDisassembly:
    """
    Computer vision-guided robotic disassembly of electronics.
    """
    def __init__(self):
        self.vision_model = self._load_vision_model()
        self.robot_arm = RobotController()
        self.component_db = ComponentDatabase()
    
    def disassemble(self, product_type: str, product_image: np.ndarray) -> dict:
        """
        Disassemble product using computer vision and robotics.
        
        Args:
            product_type: Type of product (smartphone, laptop, etc.)
            product_image: Image of product
        
        Returns:
            List of recovered components
        """
        # Identify components
        components = self.vision_model.detect_components(product_image)
        
        # Get disassembly sequence
        sequence = self.component_db.get_disassembly_sequence(product_type)
        
        # Execute disassembly
        recovered = []
        for step in sequence:
            component = self._find_component(components, step['component_type'])
            
            if component:
                # Plan grasp
                grasp_pose = self._plan_grasp(component)
                
                # Execute removal
                success = self.robot_arm.remove_component(
                    grasp_pose,
                    removal_force=step['force'],
                    removal_direction=step['direction']
                )
                
                if success:
                    recovered.append({
                        "component_type": step['component_type'],
                        "condition": self._assess_condition(component),
                        "reusable": self._check_reusable(component),
                        "value": self._estimate_value(component)
                    })
        
        return {
            "recovered_components": recovered,
            "total_value": sum(c['value'] for c in recovered),
            "reusable_count": sum(1 for c in recovered if c['reusable'])
        }
```

## Use cases

### E-waste urban mining
Extract valuable materials from discarded electronics:
1. Collect e-waste from households and businesses
2. Route to repair-preneurs via cuOpt
3. Disassemble using robotic systems
4. Recover precious metals and rare earths
5. Sell materials or reuse components

### Circular supply chain
Close material loops for manufacturers:
1. Track products via blockchain material passport
2. Design for disassembly guidelines
3. Take-back programs for end-of-life products
4. Remanufacture using recovered components
5. Zero-waste manufacturing

### Community repair hubs
Empower local repair economy:
1. Train repair-preneurs in electronics repair
2. Provide tools and workspace
3. Route repair jobs via cuOpt
4. Track repairs on blockchain for warranty
5. Build local circular economy

## Performance benchmarks

| Task | Hardware | Time | Efficiency |
|------|----------|------|------------|
| Route optimization (100 points) | Jetson AGX Orin | 2.3s | 95% optimal |
| Component detection | Jetson AGX Orin | 450ms | 92% accuracy |
| Robotic disassembly (smartphone) | Robot arm | 8 min | 85% component recovery |
| Material value assessment | Database lookup | 50ms | - |

## Integration with other stacks

### Stack 2: Kinetic & sensory
- cuOpt used for both forward and reverse logistics
- Holoscan processes vision data for robotic disassembly

### Stack 5: Humanitarian substrate
- Bio-credits reward recycling and repair
- Blockchain tracks material provenance

### Stack 8: Agricultural & climate
- Recovered materials used in agro-voltaic installations
- Circular economy reduces carbon footprint

## Regulatory compliance

- **WEEE Directive**: E-waste collection and recycling targets
- **RoHS**: Hazardous substance restrictions
- **Basel Convention**: Transboundary waste movement
- **Extended Producer Responsibility**: Manufacturer take-back obligations

## Economic impact

### Job creation
- Repair-preneurs: 1 job per 500 households
- Collection drivers: 1 job per 2000 households
- Processing technicians: 1 job per 5 repair-preneurs

### Revenue generation
- Precious metal recovery: $50-200 per ton e-waste
- Component reuse: $100-500 per ton e-waste
- Material recycling: $20-80 per ton e-waste

### Environmental benefits
- CO2 savings: 2-9 kg CO2 per kg material recycled
- Landfill diversion: 95% of e-waste
- Virgin material reduction: 80% for aluminum, 60% for copper

## Next steps

<CardGroup cols={2}>
  <Card title="Nuclear thesis overview" icon="atom" href="/nuclear-thesis/overview">
    Complete 10-stack architecture
  </Card>
  <Card title="cuOpt guide" icon="route" href="/integrations/nvidia-kinetic-sensory">
    Logistics optimization
  </Card>
  <Card title="Material passport" icon="passport" href="/integrations/humanitarian-economic">
    Blockchain traceability
  </Card>
  <Card title="Repair network" icon="screwdriver-wrench" href="/deployment/repair-network">
    Community repair hubs
  </Card>
</CardGroup>
