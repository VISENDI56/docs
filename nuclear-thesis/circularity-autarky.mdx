---
title: Stack 10 - Circularity & autarky
description: cuOpt-powered reverse logistics for zero-waste circular economy and resource autarky
---

The Circularity & Autarky stack implements zero-waste principles through GPU-accelerated reverse logistics, enabling urban mining, component harvesting, and local manufacturing for complete resource independence.

## Core capabilities

### Reverse logistics optimization
Efficient collection and processing of waste streams:
- E-waste routing to harvesting benches
- Component recovery optimization
- Repair-preneur network coordination
- Material flow tracking

### Urban mining
Extract valuable materials from waste:
- Precious metal recovery from electronics
- Rare earth element extraction
- Battery material reclamation
- Solar panel recycling

### Local manufacturing
Produce components from recycled materials:
- 3D printing with recycled plastics
- PCB fabrication from recovered copper
- Battery assembly from reclaimed cells
- Solar panel refurbishment

## Hardware architecture

**Compute**: NVIDIA GPU for cuOpt routing  
**Storage**: Material inventory database  
**Sensors**: RFID, barcode scanners, scales  
**Manufacturing**: 3D printers, CNC mills, reflow ovens

## Circular router implementation

```python core/circular_economy/reverse_logistics.py
from cuopt import routing
import numpy as np
from typing import Dict, List

class CircularRouter:
    """
    cuOpt for Reverse Logistics (Urban Mining).
    Routes E-Waste to harvesting benches.
    """
    def __init__(self):
        self.solver = routing.Solver()
        self.material_db = MaterialDatabase()
        self.repair_network = RepairPreneurNetwork()
        self.inventory = InventoryManager()
    
    def route_harvest(self, waste_type: str, location: Dict) -> Dict:
        """
        Optimize routing for waste collection and processing.
        
        Args:
            waste_type: Type of waste (e-waste, plastic, metal, etc.)
            location: Collection location coordinates
        
        Returns:
            Optimized route with processing assignments
        """
        print(f"   [Circular] Routing {waste_type} to nearest Repair-Preneur...")
        
        # Get collection points
        collection_points = self._get_collection_points(waste_type)
        
        # Get processing facilities
        facilities = self._get_processing_facilities(waste_type)
        
        # Build routing problem
        problem = self._build_reverse_logistics_problem(
            collection_points,
            facilities,
            waste_type
        )
        
        # Solve with cuOpt
        solution = self.solver.solve(
            problem,
            time_limit=10.0,
            backend="GPU_HEURISTIC"
        )
        
        # Assign processing tasks
        assignments = self._assign_processing_tasks(solution, waste_type)
        
        # Update inventory
        self._update_material_inventory(assignments)
        
        return {
            "status": "ROUTE_OPTIMIZED",
            "routes": solution.routes,
            "total_distance": solution.total_distance,
            "processing_assignments": assignments,
            "estimated_recovery": self._estimate_material_recovery(assignments)
        }
    
    def optimize_repair_network(self, demand_forecast: Dict) -> Dict:
        """
        Optimize repair-preneur network based on demand.
        
        Args:
            demand_forecast: Predicted demand for repairs/components
        
        Returns:
            Network optimization recommendations
        """
        # Get current network state
        network_state = self.repair_network.get_state()
        
        # Identify gaps in coverage
        coverage_gaps = self._identify_coverage_gaps(
            network_state,
            demand_forecast
        )
        
        # Optimize facility locations
        optimal_locations = self._optimize_facility_locations(
            coverage_gaps,
            demand_forecast
        )
        
        # Calculate material flows
        material_flows = self._calculate_material_flows(
            network_state,
            demand_forecast
        )
        
        return {
            "coverage_gaps": coverage_gaps,
            "recommended_locations": optimal_locations,
            "material_flows": material_flows,
            "network_efficiency": self._calculate_network_efficiency(network_state)
        }
    
    def track_material_lifecycle(self, material_id: str) -> Dict:
        """
        Track material from collection to reuse.
        
        Args:
            material_id: Unique material identifier (RFID/barcode)
        
        Returns:
            Complete lifecycle history
        """
        # Query material database
        lifecycle = self.material_db.get_lifecycle(material_id)
        
        return {
            "material_id": material_id,
            "origin": lifecycle['origin'],
            "collection_date": lifecycle['collection_date'],
            "processing_steps": lifecycle['processing_steps'],
            "current_state": lifecycle['current_state'],
            "reuse_applications": lifecycle['reuse_applications'],
            "carbon_offset": self._calculate_carbon_offset(lifecycle)
        }
    
    def _build_reverse_logistics_problem(
        self,
        collection_points: List[Dict],
        facilities: List[Dict],
        waste_type: str
    ) -> routing.Problem:
        """Build cuOpt problem for reverse logistics."""
        problem = routing.Problem()
        
        # Add collection points as pickup locations
        for point in collection_points:
            problem.add_location(
                lat=point['lat'],
                lon=point['lon'],
                demand=point['volume'],  # Volume to collect
                time_window=(point['available_from'], point['available_until']),
                location_type='PICKUP'
            )
        
        # Add processing facilities as delivery locations
        for facility in facilities:
            problem.add_location(
                lat=facility['lat'],
                lon=facility['lon'],
                capacity=facility['processing_capacity'],
                location_type='DELIVERY'
            )
        
        # Add vehicles (collection trucks)
        vehicles = self._get_available_vehicles(waste_type)
        for vehicle in vehicles:
            problem.add_vehicle(
                capacity=vehicle['capacity'],
                start_location=vehicle['depot'],
                end_location=vehicle['depot'],
                cost_per_km=vehicle['cost_per_km']
            )
        
        # Add constraints
        problem.add_constraint(
            routing.CapacityConstraint()  # Don't exceed vehicle capacity
        )
        
        problem.add_constraint(
            routing.TimeWindowConstraint()  # Respect collection time windows
        )
        
        # Objective: minimize total distance + processing cost
        problem.set_objective(
            routing.MinimizeCostObjective(
                distance_weight=1.0,
                processing_cost_weight=0.5
            )
        )
        
        return problem
    
    def _assign_processing_tasks(self, solution: routing.Solution, waste_type: str) -> List[Dict]:
        """Assign processing tasks to repair-preneurs."""
        assignments = []
        
        for route in solution.routes:
            for stop in route.stops:
                if stop.location_type == 'DELIVERY':
                    # Find best repair-preneur for this waste
                    repair_preneur = self.repair_network.find_best_match(
                        location=stop.location,
                        waste_type=waste_type,
                        volume=stop.volume
                    )
                    
                    assignments.append({
                        'repair_preneur_id': repair_preneur.id,
                        'waste_type': waste_type,
                        'volume': stop.volume,
                        'location': stop.location,
                        'estimated_processing_time': repair_preneur.estimate_time(waste_type, stop.volume)
                    })
        
        return assignments
    
    def _estimate_material_recovery(self, assignments: List[Dict]) -> Dict:
        """Estimate recoverable materials from assignments."""
        recovery = {
            'copper_kg': 0,
            'gold_g': 0,
            'silver_g': 0,
            'rare_earth_g': 0,
            'plastic_kg': 0,
            'steel_kg': 0
        }
        
        for assignment in assignments:
            waste_type = assignment['waste_type']
            volume = assignment['volume']
            
            # Get recovery rates from database
            rates = self.material_db.get_recovery_rates(waste_type)
            
            for material, rate in rates.items():
                if material in recovery:
                    recovery[material] += volume * rate
        
        return recovery
    
    def _update_material_inventory(self, assignments: List[Dict]):
        """Update inventory with expected material recovery."""
        for assignment in assignments:
            self.inventory.add_expected_recovery(
                repair_preneur_id=assignment['repair_preneur_id'],
                waste_type=assignment['waste_type'],
                volume=assignment['volume'],
                estimated_date=assignment.get('estimated_completion_date')
            )
    
    def _get_collection_points(self, waste_type: str) -> List[Dict]:
        """Get collection points for waste type."""
        # In production, query database
        return [
            {'lat': -1.286389, 'lon': 36.817223, 'volume': 50, 'available_from': 8, 'available_until': 18},
            {'lat': -1.292066, 'lon': 36.821945, 'volume': 30, 'available_from': 9, 'available_until': 17}
        ]
    
    def _get_processing_facilities(self, waste_type: str) -> List[Dict]:
        """Get processing facilities for waste type."""
        return [
            {'lat': -1.289000, 'lon': 36.820000, 'processing_capacity': 100},
            {'lat': -1.295000, 'lon': 36.825000, 'processing_capacity': 150}
        ]
    
    def _get_available_vehicles(self, waste_type: str) -> List[Dict]:
        """Get available collection vehicles."""
        return [
            {'capacity': 100, 'depot': {'lat': -1.290000, 'lon': 36.822000}, 'cost_per_km': 0.5}
        ]
    
    def _identify_coverage_gaps(self, network_state: Dict, demand: Dict) -> List[Dict]:
        """Identify areas with insufficient repair coverage."""
        gaps = []
        # Simplified gap analysis
        return gaps
    
    def _optimize_facility_locations(self, gaps: List[Dict], demand: Dict) -> List[Dict]:
        """Optimize new facility locations using cuOpt."""
        # Use facility location problem formulation
        return []
    
    def _calculate_material_flows(self, network_state: Dict, demand: Dict) -> Dict:
        """Calculate optimal material flows through network."""
        return {}
    
    def _calculate_network_efficiency(self, network_state: Dict) -> float:
        """Calculate network efficiency metric (0-1)."""
        return 0.85
    
    def _calculate_carbon_offset(self, lifecycle: Dict) -> float:
        """Calculate carbon offset from recycling vs. new production."""
        # Simplified calculation
        # In production, use LCA (Life Cycle Assessment) data
        return 5.2  # kg CO2 equivalent

class MaterialDatabase:
    """Database of material properties and recovery rates."""
    
    def __init__(self):
        self.materials = self._load_material_data()
    
    def get_recovery_rates(self, waste_type: str) -> Dict[str, float]:
        """Get material recovery rates for waste type."""
        rates = {
            'e-waste': {
                'copper_kg': 0.15,  # 15% copper by weight
                'gold_g': 0.3,      # 0.3g gold per kg
                'silver_g': 1.5,
                'rare_earth_g': 0.05,
                'plastic_kg': 0.25,
                'steel_kg': 0.30
            },
            'plastic': {
                'plastic_kg': 0.90  # 90% recoverable
            },
            'metal': {
                'steel_kg': 0.95,
                'copper_kg': 0.05
            }
        }
        return rates.get(waste_type, {})
    
    def get_lifecycle(self, material_id: str) -> Dict:
        """Get material lifecycle history."""
        # In production, query blockchain or database
        return {
            'origin': 'Nairobi Collection Point #42',
            'collection_date': '2025-12-15',
            'processing_steps': [
                {'step': 'Collection', 'date': '2025-12-15'},
                {'step': 'Sorting', 'date': '2025-12-16'},
                {'step': 'Disassembly', 'date': '2025-12-17'},
                {'step': 'Component Recovery', 'date': '2025-12-18'}
            ],
            'current_state': 'READY_FOR_REUSE',
            'reuse_applications': ['Solar charge controller', 'IoT sensor node']
        }
    
    def _load_material_data(self) -> Dict:
        """Load material database."""
        return {}

class RepairPreneurNetwork:
    """Network of repair-preneurs and processing facilities."""
    
    def __init__(self):
        self.repair_preneurs = self._load_network()
    
    def get_state(self) -> Dict:
        """Get current network state."""
        return {
            'total_repair_preneurs': len(self.repair_preneurs),
            'total_capacity': sum(rp['capacity'] for rp in self.repair_preneurs),
            'utilization': 0.72
        }
    
    def find_best_match(self, location: Dict, waste_type: str, volume: float):
        """Find best repair-preneur for waste processing."""
        # Simplified matching
        # In production, use cuOpt for optimal assignment
        class RepairPreneur:
            def __init__(self):
                self.id = "RP-001"
            
            def estimate_time(self, waste_type: str, volume: float) -> float:
                return volume * 0.5  # 0.5 hours per unit
        
        return RepairPreneur()
    
    def _load_network(self) -> List[Dict]:
        """Load repair-preneur network."""
        return [
            {'id': 'RP-001', 'capacity': 100, 'specialties': ['e-waste', 'electronics']},
            {'id': 'RP-002', 'capacity': 75, 'specialties': ['plastic', 'metal']}
        ]

class InventoryManager:
    """Manage material inventory."""
    
    def __init__(self):
        self.inventory = {}
    
    def add_expected_recovery(
        self,
        repair_preneur_id: str,
        waste_type: str,
        volume: float,
        estimated_date: str
    ):
        """Add expected material recovery to inventory."""
        key = f"{repair_preneur_id}_{waste_type}"
        if key not in self.inventory:
            self.inventory[key] = []
        
        self.inventory[key].append({
            'volume': volume,
            'estimated_date': estimated_date,
            'status': 'EXPECTED'
        })
```

## Use cases

### E-waste harvesting network
Urban mining for electronics:
1. Community members bring e-waste to collection points
2. CircularRouter optimizes collection routes
3. Waste routed to nearest repair-preneur
4. Components harvested (ICs, capacitors, connectors)
5. Materials tracked via RFID through lifecycle
6. Recovered components used in new devices

### Solar panel refurbishment
Extend solar panel life:
1. Damaged panels collected from field
2. Routed to refurbishment facility
3. Cells tested and sorted
4. Working cells assembled into new panels
5. Refurbished panels deployed at 60% of new cost
6. 30-year lifecycle extended by 10 years

### Plastic recycling to 3D printing
Close the loop on plastics:
1. Plastic waste collected and sorted
2. Shredded and extruded into filament
3. Filament used in 3D printers
4. Print replacement parts for devices
5. Zero plastic waste to landfill

## Performance benchmarks

| Metric | Traditional | Circular economy |
|--------|-------------|------------------|
| Material recovery rate | 15% | 85% |
| Landfill waste | 85% | 5% |
| New material cost | $100 | $30 |
| Carbon footprint | 100 kg CO2 | 20 kg CO2 |
| Local employment | 1 job | 10 jobs |

## Integration with other stacks

### Stack 2: Kinetic & sensory
- cuOpt powers both forward and reverse logistics
- Holoscan for quality inspection

### Stack 5: Humanitarian substrate
- Bio-credits for recycling participation
- Transparent material tracking on blockchain

### Stack 7: Educational sovereignty
- Vocational training for repair-preneurs
- Circular economy education

## Regulatory compliance

- **Basel Convention**: Transboundary waste movement
- **WEEE Directive**: E-waste management
- **Extended Producer Responsibility**: Manufacturer obligations
- **Right to Repair**: Consumer repair rights

## Next steps

<CardGroup cols={2}>
  <Card title="Nuclear thesis overview" icon="atom" href="/nuclear-thesis/overview">
    Return to overview
  </Card>
  <Card title="Repair-preneur program" icon="screwdriver-wrench" href="/circular-economy/repair-preneur">
    Join the network
  </Card>
  <Card title="Material database" icon="database" href="/circular-economy/materials">
    Recovery rates and specs
  </Card>
  <Card title="cuOpt routing" icon="route" href="/integrations/cuopt-logistics">
    Logistics optimization
  </Card>
</CardGroup>
