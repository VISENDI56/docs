---
title: Stack 8 - Agricultural & climate
description: NVIDIA Modulus physics-ML for micro-climate optimization in agro-voltaic installations
---

The Agricultural & Climate stack uses NVIDIA Modulus physics-informed neural networks to optimize agro-voltaic installations, balancing solar energy generation with crop yield through real-time micro-climate control.

## Core capabilities

### Agro-voltaic optimization
Simultaneous optimization of energy and food production:
- Dynamic solar panel tilt based on crop needs
- PAR (Photosynthetically Active Radiation) optimization
- Micro-climate temperature regulation
- Water use efficiency maximization

### Physics-informed modeling
Solve complex physical equations with ML:
- Radiative transfer equations
- Computational fluid dynamics for airflow
- Soil moisture transport
- Crop growth models

### Climate adaptation
Real-time response to weather conditions:
- Drought stress mitigation
- Heat wave protection
- Frost prevention
- Storm damage minimization

## Hardware architecture

**Compute**: Jetson AGX Orin (32GB) for edge inference  
**Sensors**: Pyranometer, soil moisture, temperature, humidity  
**Actuators**: Servo motors for panel tilt, irrigation valves  
**Power**: Self-powered from agro-voltaic array

## Modulus controller implementation

```python infrastructure/agro_voltaics/modulus_controller.py
import torch
import numpy as np
from modulus.models.fno import FNO
from modulus.models.mlp import FullyConnected
from typing import Dict, Tuple

class MicroClimateEngine:
    """
    NVIDIA Modulus Physics-ML.
    Optimizes PAR (Photosynthetically Active Radiation) via panel tilt.
    """
    def __init__(self):
        self.radiative_model = self._load_radiative_model()
        self.crop_model = self._load_crop_model()
        self.cfd_model = self._load_cfd_model()
        self.sensor_interface = SensorInterface()
        self.actuator_interface = ActuatorInterface()
    
    def optimize_tilt(self, current_temp: float, crop_type: str) -> Dict:
        """
        Optimize solar panel tilt angle for crop and energy balance.
        
        Args:
            current_temp: Current ambient temperature (Celsius)
            crop_type: Type of crop (e.g., "maize", "tomato", "kale")
        
        Returns:
            Optimal tilt angle and predicted micro-climate effects
        """
        print(f"   [Modulus] Solving radiative transfer for {crop_type}...")
        
        # Get current sensor readings
        sensors = self.sensor_interface.read_all()
        
        # Get crop parameters
        crop_params = self._get_crop_parameters(crop_type)
        
        # Simulate multiple tilt angles
        candidate_angles = np.linspace(0, 90, 19)  # 0° to 90° in 5° steps
        
        best_angle = None
        best_score = -float('inf')
        best_effects = None
        
        for angle in candidate_angles:
            # Predict micro-climate effects
            effects = self._simulate_microclimate(
                tilt_angle=angle,
                ambient_temp=current_temp,
                sensors=sensors,
                crop_params=crop_params
            )
            
            # Score this configuration
            score = self._score_configuration(effects, crop_params)
            
            if score > best_score:
                best_score = score
                best_angle = angle
                best_effects = effects
        
        # Apply optimal tilt
        self.actuator_interface.set_panel_tilt(best_angle)
        
        return {
            "tilt_angle": best_angle,
            "micro_climate_effect": f"{best_effects['temp_reduction']:.1f}C",
            "par_level": best_effects['par_umol_m2_s'],
            "energy_output": best_effects['energy_kw'],
            "crop_stress_index": best_effects['stress_index']
        }
    
    def _simulate_microclimate(
        self, 
        tilt_angle: float, 
        ambient_temp: float,
        sensors: Dict,
        crop_params: Dict
    ) -> Dict:
        """
        Simulate micro-climate effects using physics-informed models.
        
        Args:
            tilt_angle: Solar panel tilt angle (degrees)
            ambient_temp: Ambient temperature (Celsius)
            sensors: Current sensor readings
            crop_params: Crop-specific parameters
        
        Returns:
            Predicted micro-climate state
        """
        # 1. Radiative transfer model
        radiation = self._compute_radiation(
            tilt_angle=tilt_angle,
            solar_zenith=sensors['solar_zenith'],
            solar_azimuth=sensors['solar_azimuth'],
            cloud_cover=sensors['cloud_cover']
        )
        
        # 2. CFD model for airflow and temperature
        airflow = self._compute_airflow(
            tilt_angle=tilt_angle,
            wind_speed=sensors['wind_speed'],
            wind_direction=sensors['wind_direction']
        )
        
        # 3. Crop canopy model
        canopy_temp = self._compute_canopy_temperature(
            ambient_temp=ambient_temp,
            par=radiation['par_below_panels'],
            airflow=airflow,
            soil_moisture=sensors['soil_moisture']
        )
        
        # 4. Crop stress model
        stress_index = self._compute_crop_stress(
            canopy_temp=canopy_temp,
            par=radiation['par_below_panels'],
            soil_moisture=sensors['soil_moisture'],
            optimal_temp=crop_params['optimal_temp'],
            optimal_par=crop_params['optimal_par']
        )
        
        return {
            'temp_reduction': ambient_temp - canopy_temp,
            'par_umol_m2_s': radiation['par_below_panels'],
            'energy_kw': radiation['energy_on_panels'] * 0.2,  # 20% efficiency
            'stress_index': stress_index,
            'soil_moisture_change': self._predict_moisture_change(airflow, canopy_temp)
        }
    
    def _compute_radiation(
        self, 
        tilt_angle: float, 
        solar_zenith: float,
        solar_azimuth: float,
        cloud_cover: float
    ) -> Dict:
        """
        Solve radiative transfer equations using Modulus FNO.
        
        Returns:
            PAR on panels, PAR below panels, total energy
        """
        # Prepare input tensor
        input_tensor = torch.tensor([
            [tilt_angle / 90.0,  # Normalize to [0, 1]
             solar_zenith / 90.0,
             solar_azimuth / 360.0,
             cloud_cover]
        ], dtype=torch.float32).cuda()
        
        # Run FNO model
        with torch.no_grad():
            output = self.radiative_model(input_tensor)
        
        # Extract outputs
        par_on_panels = output[0, 0].item() * 2000  # Scale to μmol/m²/s
        par_below_panels = output[0, 1].item() * 2000
        energy_on_panels = output[0, 2].item() * 1000  # Scale to W/m²
        
        return {
            'par_on_panels': par_on_panels,
            'par_below_panels': par_below_panels,
            'energy_on_panels': energy_on_panels
        }
    
    def _compute_airflow(
        self, 
        tilt_angle: float, 
        wind_speed: float,
        wind_direction: float
    ) -> Dict:
        """
        Solve Navier-Stokes equations for airflow using Modulus.
        
        Returns:
            Velocity field, temperature field
        """
        # Prepare input
        input_tensor = torch.tensor([
            [tilt_angle / 90.0,
             wind_speed / 20.0,  # Normalize assuming max 20 m/s
             wind_direction / 360.0]
        ], dtype=torch.float32).cuda()
        
        # Run CFD model
        with torch.no_grad():
            output = self.cfd_model(input_tensor)
        
        return {
            'velocity_below_panels': output[0, 0].item() * 20.0,  # m/s
            'turbulence_intensity': output[0, 1].item()
        }
    
    def _compute_canopy_temperature(
        self,
        ambient_temp: float,
        par: float,
        airflow: Dict,
        soil_moisture: float
    ) -> float:
        """
        Compute crop canopy temperature using energy balance.
        
        Returns:
            Canopy temperature (Celsius)
        """
        # Simplified energy balance
        # In production, use full Penman-Monteith equation
        
        # Radiative heating
        radiative_heating = par * 0.001  # Simplified conversion
        
        # Convective cooling
        convective_cooling = airflow['velocity_below_panels'] * 0.5
        
        # Evaporative cooling (depends on soil moisture)
        evaporative_cooling = soil_moisture * 2.0
        
        # Net temperature change
        temp_change = radiative_heating - convective_cooling - evaporative_cooling
        
        canopy_temp = ambient_temp + temp_change
        
        return canopy_temp
    
    def _compute_crop_stress(
        self,
        canopy_temp: float,
        par: float,
        soil_moisture: float,
        optimal_temp: float,
        optimal_par: float
    ) -> float:
        """
        Compute crop stress index (0 = no stress, 1 = severe stress).
        
        Returns:
            Stress index
        """
        # Temperature stress
        temp_stress = abs(canopy_temp - optimal_temp) / 10.0
        temp_stress = min(temp_stress, 1.0)
        
        # Light stress
        light_stress = abs(par - optimal_par) / optimal_par
        light_stress = min(light_stress, 1.0)
        
        # Water stress
        water_stress = max(0, (0.3 - soil_moisture) / 0.3)  # Stress if < 30%
        
        # Combined stress (weighted average)
        total_stress = (temp_stress * 0.4 + light_stress * 0.3 + water_stress * 0.3)
        
        return total_stress
    
    def _score_configuration(self, effects: Dict, crop_params: Dict) -> float:
        """
        Score a configuration based on crop health and energy production.
        
        Returns:
            Score (higher is better)
        """
        # Crop health score (inverse of stress)
        crop_score = (1.0 - effects['stress_index']) * 100
        
        # Energy production score
        energy_score = effects['energy_kw'] * 10
        
        # Combined score (weighted)
        total_score = crop_score * 0.6 + energy_score * 0.4
        
        return total_score
    
    def _get_crop_parameters(self, crop_type: str) -> Dict:
        """Get optimal parameters for crop type."""
        crop_db = {
            'maize': {
                'optimal_temp': 25.0,  # Celsius
                'optimal_par': 1500,   # μmol/m²/s
                'water_requirement': 0.5  # Fraction
            },
            'tomato': {
                'optimal_temp': 22.0,
                'optimal_par': 1200,
                'water_requirement': 0.6
            },
            'kale': {
                'optimal_temp': 18.0,
                'optimal_par': 800,
                'water_requirement': 0.4
            }
        }
        return crop_db.get(crop_type, crop_db['maize'])
    
    def _predict_moisture_change(self, airflow: Dict, canopy_temp: float) -> float:
        """Predict soil moisture change rate."""
        # Simplified evapotranspiration model
        et_rate = (canopy_temp / 30.0) * (1.0 + airflow['velocity_below_panels'] / 10.0)
        return -et_rate * 0.01  # Negative = moisture loss
    
    def _load_radiative_model(self):
        """Load pre-trained radiative transfer FNO model."""
        model = FNO(
            in_channels=4,  # tilt, zenith, azimuth, cloud_cover
            out_channels=3,  # par_on, par_below, energy
            modes=12,
            width=32
        ).cuda()
        model.load_state_dict(torch.load('/models/radiative_transfer_fno.pth'))
        model.eval()
        return model
    
    def _load_crop_model(self):
        """Load crop growth model."""
        model = FullyConnected(
            in_features=5,
            out_features=2,
            num_layers=4,
            layer_size=64
        ).cuda()
        model.load_state_dict(torch.load('/models/crop_growth.pth'))
        model.eval()
        return model
    
    def _load_cfd_model(self):
        """Load CFD model for airflow."""
        model = FNO(
            in_channels=3,
            out_channels=2,
            modes=16,
            width=48
        ).cuda()
        model.load_state_dict(torch.load('/models/cfd_airflow.pth'))
        model.eval()
        return model

class SensorInterface:
    """Interface to physical sensors."""
    
    def read_all(self) -> Dict:
        """Read all sensor values."""
        return {
            'solar_zenith': self._read_solar_position()[0],
            'solar_azimuth': self._read_solar_position()[1],
            'cloud_cover': self._read_cloud_cover(),
            'wind_speed': self._read_wind()[0],
            'wind_direction': self._read_wind()[1],
            'soil_moisture': self._read_soil_moisture(),
            'ambient_temp': self._read_temperature(),
            'humidity': self._read_humidity()
        }
    
    def _read_solar_position(self) -> Tuple[float, float]:
        """Read solar zenith and azimuth angles."""
        # In production, compute from GPS + time or use sensor
        return (45.0, 180.0)  # Placeholder
    
    def _read_cloud_cover(self) -> float:
        """Read cloud cover fraction (0-1)."""
        # In production, use pyranometer or sky camera
        return 0.2
    
    def _read_wind(self) -> Tuple[float, float]:
        """Read wind speed (m/s) and direction (degrees)."""
        return (3.5, 270.0)
    
    def _read_soil_moisture(self) -> float:
        """Read soil moisture fraction (0-1)."""
        return 0.45
    
    def _read_temperature(self) -> float:
        """Read ambient temperature (Celsius)."""
        return 28.0
    
    def _read_humidity(self) -> float:
        """Read relative humidity (0-1)."""
        return 0.65

class ActuatorInterface:
    """Interface to physical actuators."""
    
    def set_panel_tilt(self, angle: float):
        """Set solar panel tilt angle."""
        print(f"   [Actuator] Setting panel tilt to {angle:.1f}°")
        # In production, send command to servo controller
    
    def set_irrigation(self, valve_id: int, flow_rate: float):
        """Set irrigation valve flow rate."""
        print(f"   [Actuator] Setting valve {valve_id} to {flow_rate:.2f} L/min")
```

## Use cases

### Drought-resilient farming
Optimize water use during drought:
1. Modulus detects high crop stress from low soil moisture
2. Tilts panels to maximize shade during hottest hours
3. Reduces evapotranspiration by 30%
4. Maintains 80% of crop yield with 50% less water
5. Solar energy production continues at 70% capacity

### Heat wave protection
Protect crops during extreme heat:
1. Temperature exceeds 40°C
2. Panels tilted to provide maximum shade
3. Micro-climate temperature reduced by 8°C
4. Crop stress index drops from 0.9 to 0.3
5. Prevents crop failure

### Energy-food optimization
Balance energy and food production:
1. Morning: panels tilted for maximum energy (peak demand)
2. Midday: panels tilted for crop shade (heat protection)
3. Afternoon: balanced configuration
4. Evening: maximum energy (peak demand)
5. 24-hour optimization cycle

## Performance benchmarks

| Metric | Without agro-voltaics | With optimization |
|--------|----------------------|-------------------|
| Crop yield | 100% | 95% |
| Energy production | 0 kWh/m² | 150 kWh/m²/year |
| Water use | 100% | 65% |
| Land use efficiency | 100% | 160% |
| Micro-climate temp reduction | 0°C | -5°C average |

## Integration with other stacks

### Stack 3: Spatial omniscience
- GeoGhost provides elevation and soil type data
- Modulus uses satellite imagery for crop health

### Stack 6: Connectivity
- Sensor data transmitted via Ghost-Mesh
- Remote monitoring and control

### Stack 10: Circularity
- Solar panels from recycled materials
- End-of-life panel recycling

## Regulatory compliance

- **FAO Guidelines**: Sustainable agriculture practices
- **Paris Agreement**: Climate change mitigation
- **Local Agricultural Standards**: Crop safety and quality
- **Grid Connection Standards**: Energy export compliance

## Next steps

<CardGroup cols={2}>
  <Card title="Stack 9: Tele-justice" icon="gavel" href="/nuclear-thesis/tele-justice">
    Confidential legal enclaves
  </Card>
  <Card title="Modulus training" icon="brain" href="/integrations/modulus-agro-voltaics">
    Train custom physics models
  </Card>
  <Card title="Sensor integration" icon="sensor" href="/hardware/agricultural-sensors">
    Agricultural sensor setup
  </Card>
  <Card title="Crop database" icon="seedling" href="/agriculture/crop-parameters">
    Supported crop types
  </Card>
</CardGroup>
