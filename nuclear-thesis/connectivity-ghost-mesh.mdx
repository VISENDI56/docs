---
title: Stack 6 - Connectivity & Ghost-Mesh
description: NVIDIA Aerial SDK with polymorphic mesh networking for jamming-resistant communication
---

The Connectivity & Ghost-Mesh stack combines NVIDIA Aerial SDK for 5G/6G with polymorphic mesh networking that automatically hops between protocols (LoRa, Wi-Fi Direct, Bluetooth) to maintain connectivity under adversarial conditions.

## Core capabilities

### Polymorphic mesh networking
Automatic protocol switching based on spectrum conditions:
- 5G/6G vRAN when available
- LoRa for long-range low-bandwidth
- Wi-Fi Direct for peer-to-peer
- Bluetooth mesh for ultra-local

### Jamming resistance
Spectrum analysis and adaptive hopping:
- Real-time RF spectrum monitoring
- Automatic frequency hopping
- Protocol diversity for resilience
- Cognitive radio techniques

### Offline-first architecture
Full functionality without internet:
- Local mesh routing
- Epidemic gossip protocols
- Store-and-forward messaging
- Opportunistic synchronization

## Hardware architecture

**Primary radio**: NVIDIA ConnectX-7 SmartNIC (400Gbps)  
**Secondary radios**: LoRa SX1262, ESP32 (Wi-Fi/BLE)  
**Spectrum analyzer**: HackRF One or RTL-SDR  
**Compute**: Jetson AGX Orin for baseband processing  
**Antenna**: Multi-band software-defined radio

## Aerial polymorphic implementation

```python infrastructure/aerial_6g/polymorphic_mesh.py
import numpy as np
from typing import List, Dict
import time

class AerialPolymorphic:
    """
    NVIDIA Aerial SDK on ConnectX-7.
    Hops between 5G/6G and LoRa/Wi-Fi Direct based on spectrum jamming.
    """
    def __init__(self):
        self.aerial_sdk = AerialSDK()
        self.lora_radio = LoRaRadio()
        self.wifi_direct = WiFiDirectRadio()
        self.bluetooth_mesh = BluetoothMeshRadio()
        self.spectrum_analyzer = SpectrumAnalyzer()
        self.current_mode = "MODE_5G_VRAN"
    
    def analyze_spectrum(self, rf_input: np.ndarray) -> str:
        """
        Analyze RF spectrum and select optimal protocol.
        
        Args:
            rf_input: RF spectrum data from SDR (frequency domain)
        
        Returns:
            Selected mode (MODE_5G_VRAN, MODE_LORA, MODE_WIFI_DIRECT, MODE_BLUETOOTH)
        """
        # Detect jamming signatures
        jamming_detected = self._detect_jamming(rf_input)
        
        if jamming_detected:
            print("   [Aerial] Jamming detected. Hopping to Ghost-Mesh (LoRa/Wi-Fi).")
            
            # Analyze which bands are jammed
            jammed_bands = self._identify_jammed_bands(rf_input)
            
            # Select alternative protocol
            if "2.4GHz" not in jammed_bands and "5GHz" not in jammed_bands:
                return self._switch_to_wifi_direct()
            elif "900MHz" not in jammed_bands:
                return self._switch_to_lora()
            else:
                return self._switch_to_bluetooth_mesh()
        
        # Check 5G signal quality
        signal_quality = self._measure_5g_quality()
        
        if signal_quality['rsrp'] > -100:  # Good 5G signal
            return "MODE_5G_VRAN"
        elif signal_quality['rsrp'] > -120:  # Marginal 5G
            return "MODE_5G_VRAN_LOW_POWER"
        else:
            # Fall back to mesh
            return self._select_best_mesh_protocol()
    
    def _detect_jamming(self, rf_input: np.ndarray) -> bool:
        """
        Detect jamming via spectrum analysis.
        
        Jamming signatures:
        - Abnormally high noise floor
        - Swept frequency interference
        - Pulsed interference
        - Constant carrier wave
        """
        # Compute power spectral density
        psd = np.abs(np.fft.fft(rf_input)) ** 2
        
        # Check for abnormal noise floor
        noise_floor = np.median(psd)
        peak_power = np.max(psd)
        
        if peak_power / noise_floor > 100:  # >20dB above noise
            return True
        
        # Check for swept jamming (moving peak)
        peak_history = self.spectrum_analyzer.get_peak_history()
        if self._is_swept_jamming(peak_history):
            return True
        
        # Check for pulsed jamming
        if self._is_pulsed_jamming(rf_input):
            return True
        
        return False
    
    def _switch_to_lora(self) -> str:
        """Switch to LoRa long-range mode."""
        print("   [Aerial] Switching to LoRa (SF12, BW125, CR4/8)")
        
        self.lora_radio.configure({
            'spreading_factor': 12,  # Maximum range
            'bandwidth': 125000,     # 125 kHz
            'coding_rate': 8,        # 4/8 error correction
            'frequency': 915000000,  # 915 MHz (US)
            'tx_power': 20           # 20 dBm
        })
        
        self.current_mode = "MODE_LORA"
        return "MODE_GHOST_MESH"
    
    def _switch_to_wifi_direct(self) -> str:
        """Switch to Wi-Fi Direct P2P mode."""
        print("   [Aerial] Switching to Wi-Fi Direct (P2P)")
        
        self.wifi_direct.start_group_owner({
            'ssid': 'iLuminara-Mesh',
            'channel': self._find_clear_wifi_channel(),
            'max_clients': 8
        })
        
        self.current_mode = "MODE_WIFI_DIRECT"
        return "MODE_GHOST_MESH"
    
    def _switch_to_bluetooth_mesh(self) -> str:
        """Switch to Bluetooth Mesh for ultra-local networking."""
        print("   [Aerial] Switching to Bluetooth Mesh")
        
        self.bluetooth_mesh.provision_node({
            'uuid': self._get_device_uuid(),
            'relay': True,  # Act as relay node
            'proxy': True,  # Act as proxy for non-mesh devices
            'friend': True  # Support low-power nodes
        })
        
        self.current_mode = "MODE_BLUETOOTH"
        return "MODE_GHOST_MESH"
    
    def _find_clear_wifi_channel(self) -> int:
        """Find least congested Wi-Fi channel."""
        # Scan 2.4 GHz and 5 GHz bands
        channels_24ghz = [1, 6, 11]  # Non-overlapping
        channels_5ghz = [36, 40, 44, 48, 149, 153, 157, 161]
        
        # Measure interference on each channel
        interference = {}
        for channel in channels_24ghz + channels_5ghz:
            interference[channel] = self.spectrum_analyzer.measure_channel(channel)
        
        # Select channel with lowest interference
        best_channel = min(interference, key=interference.get)
        return best_channel
    
    def route_packet(self, packet: bytes, destination: str):
        """
        Route packet through optimal protocol.
        
        Args:
            packet: Data to transmit
            destination: Destination device ID
        """
        # Check if destination is reachable via current mode
        reachable = self._check_reachability(destination, self.current_mode)
        
        if not reachable:
            # Try alternative protocols
            for mode in ["MODE_5G_VRAN", "MODE_LORA", "MODE_WIFI_DIRECT", "MODE_BLUETOOTH"]:
                if self._check_reachability(destination, mode):
                    self._switch_mode(mode)
                    break
            else:
                # Store and forward
                self._store_for_forwarding(packet, destination)
                return
        
        # Transmit via current protocol
        if self.current_mode == "MODE_5G_VRAN":
            self.aerial_sdk.transmit(packet, destination)
        elif self.current_mode == "MODE_LORA":
            self.lora_radio.transmit(packet, destination)
        elif self.current_mode == "MODE_WIFI_DIRECT":
            self.wifi_direct.send(packet, destination)
        elif self.current_mode == "MODE_BLUETOOTH":
            self.bluetooth_mesh.publish(packet, destination)

class GossipProtocol:
    """
    Epidemic gossip protocol for mesh synchronization.
    Ensures eventual consistency across disconnected nodes.
    """
    def __init__(self):
        self.message_cache = {}
        self.peer_list = []
        self.fanout = 3  # Gossip to 3 random peers
    
    def gossip_message(self, message: dict):
        """
        Propagate message through mesh network.
        
        Args:
            message: Message to propagate with metadata
        """
        message_id = self._compute_message_id(message)
        
        # Check if already seen
        if message_id in self.message_cache:
            return
        
        # Cache message
        self.message_cache[message_id] = {
            'message': message,
            'timestamp': time.time(),
            'hop_count': message.get('hop_count', 0) + 1
        }
        
        # Select random peers for gossip
        peers = self._select_random_peers(self.fanout)
        
        # Forward to peers
        for peer in peers:
            self._send_to_peer(peer, message)
    
    def _select_random_peers(self, count: int) -> List[str]:
        """Select random subset of peers for gossip."""
        import random
        return random.sample(self.peer_list, min(count, len(self.peer_list)))
    
    def _compute_message_id(self, message: dict) -> str:
        """Compute unique message ID for deduplication."""
        import hashlib
        content = json.dumps(message, sort_keys=True)
        return hashlib.sha256(content.encode()).hexdigest()[:16]

class StoreAndForward:
    """
    Store-and-forward messaging for intermittent connectivity.
    """
    def __init__(self):
        self.pending_messages = []
        self.delivery_attempts = {}
    
    def store_message(self, message: bytes, destination: str, priority: int = 5):
        """
        Store message for later delivery.
        
        Args:
            message: Message payload
            destination: Destination device ID
            priority: Priority (1=highest, 10=lowest)
        """
        self.pending_messages.append({
            'message': message,
            'destination': destination,
            'priority': priority,
            'timestamp': time.time(),
            'attempts': 0
        })
        
        # Sort by priority
        self.pending_messages.sort(key=lambda x: (x['priority'], x['timestamp']))
    
    def attempt_delivery(self, connectivity_check_fn):
        """
        Attempt to deliver pending messages.
        
        Args:
            connectivity_check_fn: Function to check if destination is reachable
        """
        delivered = []
        
        for i, msg in enumerate(self.pending_messages):
            # Check if destination is now reachable
            if connectivity_check_fn(msg['destination']):
                # Attempt delivery
                success = self._deliver_message(msg)
                
                if success:
                    delivered.append(i)
                else:
                    msg['attempts'] += 1
                    
                    # Give up after 10 attempts
                    if msg['attempts'] > 10:
                        delivered.append(i)
        
        # Remove delivered messages
        for i in reversed(delivered):
            del self.pending_messages[i]
```

## Cognitive radio implementation

```python infrastructure/aerial_6g/cognitive_radio.py
import numpy as np
from scipy import signal

class CognitiveRadio:
    """
    Cognitive radio for dynamic spectrum access.
    Finds and uses spectrum holes to avoid interference.
    """
    def __init__(self):
        self.spectrum_history = []
        self.whitespace_db = WhitespaceDatabase()
    
    def find_spectrum_holes(self, rf_input: np.ndarray, 
                           min_bandwidth: float = 1e6) -> List[Dict]:
        """
        Identify unused spectrum (whitespace) for opportunistic use.
        
        Args:
            rf_input: RF spectrum data
            min_bandwidth: Minimum required bandwidth (Hz)
        
        Returns:
            List of available spectrum holes with center frequency and bandwidth
        """
        # Compute power spectral density
        freqs, psd = signal.welch(rf_input, fs=20e6, nperseg=1024)
        
        # Detect occupied bands (energy detection)
        threshold = np.median(psd) + 10  # 10 dB above noise floor
        occupied = psd > threshold
        
        # Find contiguous unoccupied regions
        holes = []
        in_hole = False
        hole_start = 0
        
        for i, is_occupied in enumerate(occupied):
            if not is_occupied and not in_hole:
                # Start of hole
                hole_start = i
                in_hole = True
            elif is_occupied and in_hole:
                # End of hole
                hole_bandwidth = (i - hole_start) * (freqs[1] - freqs[0])
                
                if hole_bandwidth >= min_bandwidth:
                    holes.append({
                        'center_freq': freqs[hole_start + (i - hole_start) // 2],
                        'bandwidth': hole_bandwidth,
                        'start_freq': freqs[hole_start],
                        'end_freq': freqs[i]
                    })
                
                in_hole = False
        
        return holes
    
    def select_optimal_channel(self, holes: List[Dict], 
                              required_bandwidth: float) -> Dict:
        """
        Select best spectrum hole based on bandwidth and stability.
        
        Args:
            holes: Available spectrum holes
            required_bandwidth: Required bandwidth for transmission
        
        Returns:
            Selected channel parameters
        """
        # Filter holes with sufficient bandwidth
        suitable = [h for h in holes if h['bandwidth'] >= required_bandwidth]
        
        if not suitable:
            raise ValueError("No suitable spectrum holes found")
        
        # Score each hole based on:
        # - Bandwidth (more is better)
        # - Stability (check historical data)
        # - Interference level
        
        scores = []
        for hole in suitable:
            stability = self._check_stability(hole['center_freq'])
            interference = self._measure_interference(hole['center_freq'])
            
            score = (hole['bandwidth'] / required_bandwidth) * stability * (1 - interference)
            scores.append(score)
        
        # Select hole with highest score
        best_idx = np.argmax(scores)
        return suitable[best_idx]
    
    def _check_stability(self, center_freq: float) -> float:
        """
        Check historical stability of frequency band.
        
        Returns:
            Stability score (0-1, higher is more stable)
        """
        # Check if this frequency has been consistently available
        history = [h for h in self.spectrum_history if abs(h['freq'] - center_freq) < 1e6]
        
        if len(history) < 10:
            return 0.5  # Unknown stability
        
        # Calculate percentage of time available
        available_count = sum(1 for h in history if h['available'])
        return available_count / len(history)
```

## Use cases

### Disaster response communication
Maintain connectivity when infrastructure is destroyed:
1. 5G towers down due to earthquake
2. Aerial SDK detects loss of signal
3. Automatic switch to LoRa mesh
4. Store-and-forward for intermittent connectivity
5. Gossip protocol synchronizes data when nodes meet

### Military-grade jamming resistance
Operate under adversarial jamming:
1. Spectrum analyzer detects swept jamming
2. Cognitive radio finds spectrum holes
3. Frequency hopping across multiple bands
4. Protocol diversity (5G → LoRa → Wi-Fi → Bluetooth)
5. Maintains connectivity despite 80% spectrum denial

### Rural connectivity
Bridge the digital divide:
1. No cellular coverage in remote village
2. LoRa gateway connects to nearest town (10km range)
3. Local Wi-Fi Direct mesh for village devices
4. Store-and-forward for delay-tolerant data
5. Opportunistic sync when vehicle passes through

## Performance benchmarks

| Protocol | Range | Bandwidth | Latency | Power |
|----------|-------|-----------|---------|-------|
| 5G vRAN | 1 km | 1 Gbps | 10 ms | 2W |
| LoRa SF12 | 15 km | 250 bps | 2 sec | 100 mW |
| Wi-Fi Direct | 200 m | 250 Mbps | 20 ms | 500 mW |
| Bluetooth Mesh | 50 m | 1 Mbps | 100 ms | 10 mW |

## Integration with other stacks

### Stack 2: Kinetic & sensory
- Holoscan adapts compression based on Ghost-Mesh bandwidth
- cuOpt routing considers network topology

### Stack 3: Spatial omniscience
- GeoGhost P2P sync uses Ghost-Mesh transport
- Map updates propagate via gossip protocol

### Stack 5: Humanitarian substrate
- Blockchain nodes sync over intermittent connectivity
- Store-and-forward for transaction propagation

## Regulatory compliance

- **FCC Part 15**: Unlicensed spectrum usage rules
- **ETSI EN 300 220**: European short-range devices
- **ITU Radio Regulations**: International spectrum allocation
- **Cognitive Radio**: Dynamic spectrum access compliance

## Next steps

<CardGroup cols={2}>
  <Card title="Stack 7: Educational sovereignty" icon="graduation-cap" href="/nuclear-thesis/educational-sovereignty">
    Knowledge Mesh offline learning
  </Card>
  <Card title="Aerial SDK setup" icon="tower-broadcast" href="/deployment/aerial-6g">
    NVIDIA Aerial deployment guide
  </Card>
  <Card title="LoRa configuration" icon="radio" href="/integrations/lora-mesh">
    LoRaWAN mesh networking
  </Card>
  <Card title="Spectrum analysis" icon="wave-square" href="/security/spectrum-monitoring">
    RF spectrum monitoring
  </Card>
</CardGroup>
