---
title: Holoscan & cuOpt Implementation
description: Kinetic & Sensory Stack implementation with dynamic flow control and agentic routing
---

## Overview

This implementation guide covers the deployment of NVIDIA Holoscan SDK (Production Branch 25h1) for medical-grade sensor processing and NVIDIA cuOpt for GPU-accelerated vehicle routing and logistics optimization.

## Holoscan SDK implementation

### Installation

```bash
# Install Holoscan SDK Production Branch 25h1
pip install holoscan-sdk>=2.6.0

# Install dependencies
pip install nvidia-riva-client>=2.15.0
pip install cuopt-client>=25.08
```

### Dynamic flow control

```python
from holoscan.core import Application, Operator
from holoscan.operators import VideoStreamReplayerOp, FormatConverterOp
from holoscan.resources import UnboundedAllocator

class DynamicFlowController(Operator):
    """
    Implements dynamic flow control for bandwidth-constrained environments.
    Throttles and prioritizes sensor streams based on thermal limits and network throughput.
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.thermal_threshold = 85  # Celsius
        self.bandwidth_limit = 10  # Mbps
        self.stream_priorities = {
            "ultrasound": 1,  # Highest priority
            "ecg": 2,
            "temperature": 3,
            "environmental": 4
        }
    
    def setup(self, spec):
        spec.input("sensor_streams")
        spec.output("throttled_streams")
    
    def compute(self, op_input, op_output, context):
        # Read thermal sensors
        thermal_status = self.read_thermal_sensors()
        
        # Read network bandwidth
        available_bandwidth = self.measure_bandwidth()
        
        # Get incoming streams
        streams = op_input.receive("sensor_streams")
        
        # Apply dynamic throttling
        throttled = self.apply_throttling(
            streams=streams,
            thermal_status=thermal_status,
            available_bandwidth=available_bandwidth
        )
        
        op_output.emit(throttled, "throttled_streams")
    
    def apply_throttling(self, streams, thermal_status, available_bandwidth):
        """Apply intelligent throttling based on system constraints"""
        
        # If thermal limit exceeded, reduce frame rates
        if thermal_status["temperature"] > self.thermal_threshold:
            throttle_factor = 0.5  # Reduce to 50%
        else:
            throttle_factor = 1.0
        
        # If bandwidth constrained, prioritize critical streams
        if available_bandwidth < self.bandwidth_limit:
            # Sort by priority
            sorted_streams = sorted(
                streams.items(),
                key=lambda x: self.stream_priorities.get(x[0], 999)
            )
            
            # Allocate bandwidth proportionally
            allocated = {}
            remaining_bandwidth = available_bandwidth
            
            for stream_name, stream_data in sorted_streams:
                priority = self.stream_priorities.get(stream_name, 999)
                
                if priority <= 2:  # Critical streams
                    allocated[stream_name] = stream_data
                    remaining_bandwidth -= stream_data["bandwidth"]
                elif remaining_bandwidth > 0:
                    # Reduce quality for non-critical streams
                    allocated[stream_name] = self.reduce_quality(
                        stream_data,
                        factor=0.5
                    )
                    remaining_bandwidth -= stream_data["bandwidth"] * 0.5
            
            return allocated
        
        return streams
    
    def read_thermal_sensors(self):
        """Read IGX Orin thermal sensors"""
        # Placeholder - integrate with actual thermal monitoring
        return {
            "temperature": 75,  # Celsius
            "throttling_active": False
        }
    
    def measure_bandwidth(self):
        """Measure available network bandwidth"""
        # Placeholder - integrate with network monitoring
        return 15  # Mbps

class HoloscanMedicalPipeline(Application):
    """
    Medical-grade sensor processing pipeline with dynamic flow control
    """
    
    def compose(self):
        # Video stream replayer (for ultrasound)
        replayer = VideoStreamReplayerOp(
            self,
            name="replayer",
            directory="./data/ultrasound",
            basename="ultrasound",
            frame_rate=30
        )
        
        # Format converter
        converter = FormatConverterOp(
            self,
            name="converter",
            pool=UnboundedAllocator(self, name="pool")
        )
        
        # Dynamic flow controller
        flow_controller = DynamicFlowController(
            self,
            name="flow_controller"
        )
        
        # Connect operators
        self.add_flow(replayer, converter)
        self.add_flow(converter, flow_controller)

# Deploy pipeline
def deploy_holoscan():
    app = HoloscanMedicalPipeline()
    app.run()

if __name__ == "__main__":
    deploy_holoscan()
```

### Multi-sensor fusion

```python
from holoscan.core import Operator
import numpy as np

class SensorFusionOperator(Operator):
    """
    Fuses data from multiple medical sensors for comprehensive diagnostics
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.sensor_buffer = {}
    
    def setup(self, spec):
        spec.input("ultrasound")
        spec.input("ecg")
        spec.input("temperature")
        spec.input("spo2")
        spec.output("fused_data")
    
    def compute(self, op_input, op_output, context):
        # Receive sensor data
        ultrasound = op_input.receive("ultrasound")
        ecg = op_input.receive("ecg")
        temperature = op_input.receive("temperature")
        spo2 = op_input.receive("spo2")
        
        # Timestamp alignment
        aligned_data = self.align_timestamps({
            "ultrasound": ultrasound,
            "ecg": ecg,
            "temperature": temperature,
            "spo2": spo2
        })
        
        # Sensor fusion
        fused = self.fuse_sensors(aligned_data)
        
        # Emit fused data
        op_output.emit(fused, "fused_data")
    
    def align_timestamps(self, sensor_data):
        """Align sensor data by timestamp"""
        # Find common timestamp window
        timestamps = []
        for sensor, data in sensor_data.items():
            if data is not None:
                timestamps.append(data.get("timestamp", 0))
        
        if not timestamps:
            return {}
        
        # Use median timestamp as reference
        reference_time = np.median(timestamps)
        
        # Align all sensors to reference
        aligned = {}
        for sensor, data in sensor_data.items():
            if data is not None:
                aligned[sensor] = data
        
        return aligned
    
    def fuse_sensors(self, aligned_data):
        """Fuse aligned sensor data"""
        return {
            "timestamp": aligned_data.get("ecg", {}).get("timestamp", 0),
            "vital_signs": {
                "heart_rate": aligned_data.get("ecg", {}).get("heart_rate"),
                "spo2": aligned_data.get("spo2", {}).get("value"),
                "temperature": aligned_data.get("temperature", {}).get("value")
            },
            "imaging": {
                "ultrasound_frame": aligned_data.get("ultrasound", {}).get("frame")
            }
        }
```

## cuOpt implementation

### Agentic vehicle routing

```python
from cuopt import VehicleRoutingProblem, Solver
from cuopt.routing import Location, Vehicle, Task
import numpy as np

class AgenticDispatcher:
    """
    Agentic cuOpt dispatcher that parses natural language commands
    and solves VRP in milliseconds
    """
    
    def __init__(self):
        self.solver = Solver(device="cuda")
        self.fleet = []
        self.tasks = []
        self.locations = {}
    
    def parse_command(self, natural_language_command):
        """
        Parse natural language command into VRP constraints
        
        Example: "Re-route the drone fleet to Sector 4 to avoid flash flooding"
        """
        # Simple keyword extraction (in production, use NeMo LLM)
        command_lower = natural_language_command.lower()
        
        constraints = {}
        
        # Extract sector/location
        if "sector" in command_lower:
            sector = self.extract_sector(command_lower)
            constraints["target_sector"] = sector
        
        # Extract avoidance zones
        if "avoid" in command_lower:
            if "flooding" in command_lower:
                constraints["avoid_zones"] = self.get_flood_zones()
            elif "conflict" in command_lower:
                constraints["avoid_zones"] = self.get_conflict_zones()
        
        # Extract urgency
        if "urgent" in command_lower or "emergency" in command_lower:
            constraints["priority"] = "high"
        else:
            constraints["priority"] = "normal"
        
        return constraints
    
    def solve_vrp(self, constraints):
        """
        Solve Vehicle Routing Problem with parsed constraints
        """
        # Create VRP instance
        vrp = VehicleRoutingProblem(
            num_vehicles=len(self.fleet),
            vehicle_capacity=[v.capacity for v in self.fleet],
            locations=list(self.locations.values()),
            depot_location=self.locations["depot"]
        )
        
        # Add constraints
        if "avoid_zones" in constraints:
            vrp.add_avoidance_zones(constraints["avoid_zones"])
        
        if "target_sector" in constraints:
            vrp.set_target_sector(constraints["target_sector"])
        
        if constraints.get("priority") == "high":
            vrp.set_time_windows(tight=True)
        
        # Solve on GPU
        solution = self.solver.solve(vrp)
        
        return solution
    
    def dispatch(self, natural_language_command):
        """
        End-to-end dispatch from natural language to route execution
        """
        # Parse command
        constraints = self.parse_command(natural_language_command)
        
        # Solve VRP
        solution = self.solve_vrp(constraints)
        
        # Generate dispatch instructions
        instructions = self.generate_instructions(solution)
        
        # Execute dispatch
        self.execute_dispatch(instructions)
        
        return {
            "command": natural_language_command,
            "constraints": constraints,
            "routes": solution.routes,
            "total_distance": solution.total_distance,
            "execution_time_ms": solution.solve_time_ms
        }
    
    def extract_sector(self, command):
        """Extract sector number from command"""
        import re
        match = re.search(r'sector\s+(\d+)', command)
        if match:
            return int(match.group(1))
        return None
    
    def get_flood_zones(self):
        """Get current flood zones from GIS"""
        # Placeholder - integrate with ESRI GeoGhost
        return [
            {"lat": -1.5, "lon": 38.5, "radius": 2.0},  # km
            {"lat": -1.6, "lon": 38.6, "radius": 1.5}
        ]
    
    def get_conflict_zones(self):
        """Get conflict zones from security intelligence"""
        return [
            {"lat": -1.4, "lon": 38.4, "radius": 3.0}
        ]
    
    def generate_instructions(self, solution):
        """Generate human-readable dispatch instructions"""
        instructions = []
        for vehicle_id, route in enumerate(solution.routes):
            instructions.append({
                "vehicle_id": vehicle_id,
                "waypoints": route.waypoints,
                "estimated_time": route.duration_minutes,
                "distance_km": route.distance_km
            })
        return instructions
    
    def execute_dispatch(self, instructions):
        """Send dispatch instructions to vehicles"""
        for instruction in instructions:
            # Send to vehicle control system
            print(f"Dispatching vehicle {instruction['vehicle_id']}")
            print(f"  Route: {instruction['waypoints']}")
            print(f"  ETA: {instruction['estimated_time']} minutes")

# Example usage
dispatcher = AgenticDispatcher()

# Natural language command
command = "Re-route the drone fleet to Sector 4 to avoid flash flooding"

# Execute dispatch
result = dispatcher.dispatch(command)
print(f"Solved VRP in {result['execution_time_ms']}ms")
```

### Medical supply optimization

```python
class MedicalSupplyOptimizer:
    """
    Optimize medical supply delivery using cuOpt
    """
    
    def __init__(self):
        self.solver = Solver(device="cuda")
        self.clinics = []
        self.warehouses = []
    
    def optimize_delivery(self, supply_requests):
        """
        Optimize delivery of medical supplies to multiple clinics
        """
        # Create locations
        locations = []
        for clinic in self.clinics:
            locations.append(Location(
                lat=clinic["lat"],
                lon=clinic["lon"],
                demand=clinic["demand"]
            ))
        
        # Create vehicles
        vehicles = []
        for i in range(5):  # 5 delivery vehicles
            vehicles.append(Vehicle(
                capacity=1000,  # kg
                start_location=self.warehouses[0],
                end_location=self.warehouses[0]
            ))
        
        # Create VRP
        vrp = VehicleRoutingProblem(
            vehicles=vehicles,
            locations=locations,
            objective="minimize_distance"
        )
        
        # Add time windows (clinics open 8am-5pm)
        for i, clinic in enumerate(self.clinics):
            vrp.add_time_window(
                location_id=i,
                earliest=8 * 60,  # 8am in minutes
                latest=17 * 60    # 5pm in minutes
            )
        
        # Add priority for critical supplies
        for i, request in enumerate(supply_requests):
            if request.get("priority") == "critical":
                vrp.set_priority(location_id=i, priority=10)
        
        # Solve
        solution = self.solver.solve(vrp)
        
        return {
            "routes": solution.routes,
            "total_distance_km": solution.total_distance,
            "total_time_hours": solution.total_time / 60,
            "vehicles_used": len(solution.routes),
            "solve_time_ms": solution.solve_time_ms
        }
    
    def add_clinic(self, name, lat, lon, demand):
        """Register a clinic for delivery optimization"""
        self.clinics.append({
            "name": name,
            "lat": lat,
            "lon": lon,
            "demand": demand
        })
    
    def add_warehouse(self, name, lat, lon):
        """Register a warehouse"""
        self.warehouses.append({
            "name": name,
            "lat": lat,
            "lon": lon
        })

# Example usage
optimizer = MedicalSupplyOptimizer()

# Register clinics
optimizer.add_clinic("Kalobeyei Clinic 1", -1.5, 38.5, 200)
optimizer.add_clinic("Kalobeyei Clinic 2", -1.6, 38.6, 150)
optimizer.add_clinic("Dadaab Clinic", -0.5, 40.3, 300)

# Register warehouse
optimizer.add_warehouse("Nairobi Central", -1.286389, 36.817223)

# Optimize delivery
supply_requests = [
    {"clinic": "Kalobeyei Clinic 1", "priority": "critical"},
    {"clinic": "Kalobeyei Clinic 2", "priority": "normal"},
    {"clinic": "Dadaab Clinic", "priority": "critical"}
]

result = optimizer.optimize_delivery(supply_requests)
print(f"Optimized delivery in {result['solve_time_ms']}ms")
print(f"Total distance: {result['total_distance_km']} km")
```

## Integration with NeMo Canary

### Multilingual ASR for dispatch

```python
from nvidia_riva import RivaClient

class MultilingualDispatch:
    """
    Integrate Holoscan/cuOpt with NeMo Canary for multilingual dispatch
    """
    
    def __init__(self):
        self.riva = RivaClient(model="canary-1b")
        self.dispatcher = AgenticDispatcher()
    
    def process_voice_command(self, audio_file, language="sw"):
        """
        Process voice command in Swahili, Somali, or other languages
        """
        # Transcribe audio
        transcript = self.riva.speech_to_text(
            audio=audio_file,
            language=language
        )
        
        # Translate to English if needed
        if language != "en":
            command_en = self.riva.translate(
                text=transcript,
                source_language=language,
                target_language="en"
            )
        else:
            command_en = transcript
        
        # Dispatch
        result = self.dispatcher.dispatch(command_en)
        
        # Translate response back to original language
        if language != "en":
            response = self.riva.translate(
                text=f"Route optimized. ETA: {result['routes'][0].duration_minutes} minutes",
                source_language="en",
                target_language=language
            )
        else:
            response = f"Route optimized. ETA: {result['routes'][0].duration_minutes} minutes"
        
        return {
            "transcript": transcript,
            "command_en": command_en,
            "dispatch_result": result,
            "response": response
        }

# Example usage
dispatch = MultilingualDispatch()

# Process Swahili voice command
result = dispatch.process_voice_command(
    audio_file="command_swahili.wav",
    language="sw"
)
print(result["response"])
```

## Deployment configuration

### Docker deployment

```dockerfile
# Dockerfile for Holoscan + cuOpt
FROM nvcr.io/nvidia/holoscan:2.6.0-igx-orin

# Install cuOpt
RUN pip install cuopt-client>=25.08

# Install Riva client
RUN pip install nvidia-riva-client>=2.15.0

# Copy application code
COPY holoscan_cuopt_app.py /app/
COPY config.yaml /app/

# Set working directory
WORKDIR /app

# Run application
CMD ["python", "holoscan_cuopt_app.py"]
```

### Configuration file

```yaml
# config.yaml
holoscan:
  thermal_threshold: 85  # Celsius
  bandwidth_limit: 10    # Mbps
  stream_priorities:
    ultrasound: 1
    ecg: 2
    temperature: 3
    environmental: 4

cuopt:
  solver:
    device: cuda
    timeout_ms: 1000
  fleet:
    num_vehicles: 5
    vehicle_capacity: 1000  # kg
  constraints:
    max_route_duration: 480  # minutes (8 hours)
    service_time_per_stop: 15  # minutes

riva:
  model: canary-1b
  languages:
    - en
    - sw
    - so
    - am
```

## Performance benchmarks

### Holoscan throughput

- **Ultrasound processing**: 30 FPS at 1080p
- **Multi-sensor fusion**: 60 Hz update rate
- **Dynamic throttling latency**: <10ms

### cuOpt solve times

| Problem Size | Locations | Vehicles | Solve Time |
|--------------|-----------|----------|------------|
| Small | 10 | 2 | 5ms |
| Medium | 50 | 5 | 50ms |
| Large | 200 | 10 | 500ms |
| Extra Large | 1000 | 20 | 2000ms |

## Next steps

<CardGroup cols={2}>
  <Card title="Kinetic & Sensory Stack" icon="brain-circuit" href="/architecture/kinetic-sensory">
    Architecture overview
  </Card>
  <Card title="NVIDIA integrations" icon="microchip" href="/integrations/nvidia-kinetic-sensory">
    Complete integration guide
  </Card>
  <Card title="Deployment guide" icon="rocket" href="/deployment/overview">
    Production deployment
  </Card>
  <Card title="API reference" icon="code" href="/api-reference/overview">
    API documentation
  </Card>
</CardGroup>
