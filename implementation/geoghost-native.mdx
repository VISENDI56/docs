---
title: GeoGhost Native Implementation
description: ESRI ArcGIS Maps SDK for offline-first spatial omniscience
---

## Overview

The GeoGhost Native implementation provides **offline-first GIS capabilities** using the ESRI ArcGIS Maps SDK for Native Apps. This enables total situational awareness even when the global internet is severed, with peer-to-peer synchronization and GPU-accelerated physics simulations.

## Architecture

GeoGhost moves the GIS core from the browser to the device's metal (C++ core wrapped in Qt/Kotlin), enabling:

- **Offline vector tile packages** (.vtpk)
- **Mobile map packages** (.mmpk)
- **Peer-to-peer gossip synchronization**
- **GPU physics simulation** (NVIDIA Modulus integration)

## Installation

### Python SDK

```bash
# Install ArcGIS Maps SDK for Python
pip install arcgis>=200.5.0
pip install arcgis-learn>=2.4.0

# Install dependencies
pip install numpy>=1.24.0
pip install pandas>=2.0.0
```

### Qt/C++ SDK (for native apps)

```bash
# Download from ESRI
# https://developers.arcgis.com/qt/

# Install Qt dependencies
sudo apt-get install qt6-base-dev
sudo apt-get install qt6-positioning-dev
```

## Core components

<CardGroup cols={2}>
  <Card title="Offline packages" icon="box">
    .vtpk and .mmpk for disconnected operation
  </Card>
  <Card title="P2P sync" icon="arrows-rotate">
    Wi-Fi Direct gossip protocol
  </Card>
  <Card title="Physics simulation" icon="atom">
    GPU-accelerated flood modeling
  </Card>
  <Card title="Real-time overlay" icon="layer-group">
    Zero-latency risk visualization
  </Card>
</CardGroup>

## Offline map packages

### Creating vector tile packages

```python
from arcgis.gis import GIS
from arcgis.mapping import VectorTileLayer
import os

class OfflineMapBuilder:
    def __init__(self, portal_url=None, username=None, password=None):
        # Connect to ArcGIS Online or Portal
        if portal_url:
            self.gis = GIS(portal_url, username, password)
        else:
            self.gis = GIS()  # Anonymous access
    
    def create_vtpk(self, extent, output_path):
        """
        Create vector tile package for offline use
        
        Args:
            extent: (xmin, ymin, xmax, ymax) in WGS84
            output_path: Path to save .vtpk file
        """
        # Get basemap
        basemap = self.gis.content.search(
            "World Topographic Map",
            item_type="Vector Tile Service"
        )[0]
        
        # Create vector tile layer
        vtl = VectorTileLayer.fromitem(basemap)
        
        # Export to VTPK
        vtpk_item = vtl.export_tiles(
            area=extent,
            export_by="LevelID",
            levels="0-16",  # Zoom levels
            tile_package=True
        )
        
        # Download
        vtpk_item.download(save_path=output_path)
        
        return output_path
    
    def create_mmpk(self, extent, layers, output_path):
        """
        Create mobile map package with multiple layers
        
        Args:
            extent: (xmin, ymin, xmax, ymax)
            layers: List of layer URLs
            output_path: Path to save .mmpk file
        """
        from arcgis.mapping import WebMap
        
        # Create web map
        webmap = WebMap()
        
        # Add basemap
        webmap.basemap = "topo-vector"
        
        # Add operational layers
        for layer_url in layers:
            webmap.add_layer({"url": layer_url})
        
        # Export to MMPK
        mmpk_item = webmap.offline_areas.create(
            area=extent,
            item_properties={
                "title": "Kalobeyei Offline Map",
                "snippet": "Offline map for Kalobeyei refugee settlement"
            }
        )
        
        # Download
        mmpk_item.download(save_path=output_path)
        
        return output_path

# Example usage
builder = OfflineMapBuilder()

# Kalobeyei extent (Kenya)
kalobeyei_extent = (34.8, 3.3, 34.9, 3.4)

# Create VTPK
vtpk_path = builder.create_vtpk(
    extent=kalobeyei_extent,
    output_path="/data/maps/kalobeyei.vtpk"
)

# Create MMPK with health facilities
mmpk_path = builder.create_mmpk(
    extent=kalobeyei_extent,
    layers=[
        "https://services.arcgis.com/health_facilities",
        "https://services.arcgis.com/water_points"
    ],
    output_path="/data/maps/kalobeyei.mmpk"
)
```

### Loading offline maps

```python
from arcgis.mapping import Map
from arcgis.gis import GIS

class OfflineMapViewer:
    def __init__(self, mmpk_path):
        self.gis = GIS()  # Offline mode
        self.map = Map()
        self.mmpk_path = mmpk_path
    
    def load_offline_map(self):
        # Load mobile map package
        from arcgis.mapping import MobileMapPackage
        
        mmpk = MobileMapPackage(self.mmpk_path)
        
        # Get first map
        offline_map = mmpk.maps[0]
        
        # Display
        self.map = offline_map
        
        return self.map
    
    def query_features(self, layer_name, where_clause="1=1"):
        # Query features from offline layer
        layer = self.map.layers[layer_name]
        
        features = layer.query(where=where_clause)
        
        return features.features

# Example usage
viewer = OfflineMapViewer("/data/maps/kalobeyei.mmpk")
offline_map = viewer.load_offline_map()

# Query health facilities
health_facilities = viewer.query_features(
    layer_name="health_facilities",
    where_clause="status='operational'"
)
```

## Peer-to-peer synchronization

### Gossip protocol implementation

```python
import socket
import json
import threading
import time
from datetime import datetime

class GeoGossipProtocol:
    def __init__(self, node_id, port=5000):
        self.node_id = node_id
        self.port = port
        self.peers = {}
        self.local_data = {}
        self.running = False
    
    def start(self):
        # Start listening for peers
        self.running = True
        
        # Discovery thread
        self.discovery_thread = threading.Thread(
            target=self._discover_peers
        )
        self.discovery_thread.start()
        
        # Sync thread
        self.sync_thread = threading.Thread(
            target=self._sync_loop
        )
        self.sync_thread.start()
    
    def _discover_peers(self):
        # Broadcast presence on local network
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        
        while self.running:
            # Broadcast announcement
            message = json.dumps({
                "type": "announce",
                "node_id": self.node_id,
                "port": self.port,
                "timestamp": datetime.now().isoformat()
            })
            
            sock.sendto(
                message.encode(),
                ('<broadcast>', self.port)
            )
            
            time.sleep(30)  # Announce every 30 seconds
    
    def _sync_loop(self):
        # Listen for sync requests
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('', self.port))
        
        while self.running:
            try:
                data, addr = sock.recvfrom(4096)
                message = json.loads(data.decode())
                
                if message["type"] == "announce":
                    # Add peer
                    self.peers[message["node_id"]] = {
                        "address": addr[0],
                        "port": message["port"],
                        "last_seen": datetime.now()
                    }
                
                elif message["type"] == "sync_request":
                    # Send local data
                    self._send_data(addr)
                
                elif message["type"] == "sync_data":
                    # Merge received data
                    self._merge_data(message["data"])
            
            except Exception as e:
                print(f"Sync error: {e}")
    
    def _send_data(self, peer_addr):
        # Send local data to peer
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        
        message = json.dumps({
            "type": "sync_data",
            "node_id": self.node_id,
            "data": self.local_data,
            "timestamp": datetime.now().isoformat()
        })
        
        sock.sendto(message.encode(), peer_addr)
    
    def _merge_data(self, peer_data):
        # Merge peer data with local data
        for key, value in peer_data.items():
            if key not in self.local_data:
                # New data
                self.local_data[key] = value
            else:
                # Conflict resolution: last-write-wins
                if value["timestamp"] > self.local_data[key]["timestamp"]:
                    self.local_data[key] = value
    
    def add_feature(self, feature_id, geometry, attributes):
        # Add new feature to local data
        self.local_data[feature_id] = {
            "geometry": geometry,
            "attributes": attributes,
            "timestamp": datetime.now().isoformat(),
            "node_id": self.node_id
        }
    
    def stop(self):
        self.running = False
        self.discovery_thread.join()
        self.sync_thread.join()

# Example usage
gossip = GeoGossipProtocol(node_id="chv_001")
gossip.start()

# Add epidemiological data
gossip.add_feature(
    feature_id="cholera_case_001",
    geometry={"x": 34.85, "y": 3.35},
    attributes={
        "case_type": "cholera",
        "date": "2026-01-15",
        "status": "confirmed"
    }
)
```

### Sync-enabled feature services

```python
from arcgis.features import FeatureLayer
from arcgis.gis import GIS
import sqlite3

class SyncEnabledFeatureService:
    def __init__(self, feature_service_url, local_db_path):
        self.gis = GIS()
        self.feature_layer = FeatureLayer(feature_service_url)
        self.local_db = sqlite3.connect(local_db_path)
        self._init_local_db()
    
    def _init_local_db(self):
        # Create local replica of feature service
        cursor = self.local_db.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS features (
                objectid INTEGER PRIMARY KEY,
                geometry TEXT,
                attributes TEXT,
                timestamp TEXT,
                sync_status TEXT
            )
        ''')
        
        self.local_db.commit()
    
    def sync_down(self):
        # Download features from service
        features = self.feature_layer.query()
        
        cursor = self.local_db.cursor()
        
        for feature in features.features:
            cursor.execute('''
                INSERT OR REPLACE INTO features
                (objectid, geometry, attributes, timestamp, sync_status)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                feature.attributes['OBJECTID'],
                json.dumps(feature.geometry),
                json.dumps(feature.attributes),
                datetime.now().isoformat(),
                'synced'
            ))
        
        self.local_db.commit()
    
    def sync_up(self):
        # Upload local changes to service
        cursor = self.local_db.cursor()
        
        # Get unsynced features
        cursor.execute('''
            SELECT objectid, geometry, attributes
            FROM features
            WHERE sync_status = 'pending'
        ''')
        
        pending = cursor.fetchall()
        
        # Upload to service
        for objectid, geometry, attributes in pending:
            feature = {
                "geometry": json.loads(geometry),
                "attributes": json.loads(attributes)
            }
            
            self.feature_layer.edit_features(updates=[feature])
            
            # Mark as synced
            cursor.execute('''
                UPDATE features
                SET sync_status = 'synced'
                WHERE objectid = ?
            ''', (objectid,))
        
        self.local_db.commit()
    
    def add_feature_offline(self, geometry, attributes):
        # Add feature while offline
        cursor = self.local_db.cursor()
        
        cursor.execute('''
            INSERT INTO features
            (geometry, attributes, timestamp, sync_status)
            VALUES (?, ?, ?, ?)
        ''', (
            json.dumps(geometry),
            json.dumps(attributes),
            datetime.now().isoformat(),
            'pending'
        ))
        
        self.local_db.commit()
```

## GPU physics simulation

### Flood modeling with NVIDIA Modulus

```python
from arcgis.raster import Raster
from arcgis.gis import GIS
import numpy as np

class FloodSimulator:
    def __init__(self, dem_path, modulus_model):
        self.dem = Raster(dem_path)
        self.modulus_model = modulus_model
    
    def simulate_flood(self, rainfall_mm, duration_hours):
        # Get elevation data
        elevation = self.dem.read()
        
        # Run physics simulation on GPU
        flood_depth = self.modulus_model.simulate(
            elevation=elevation,
            rainfall=rainfall_mm,
            duration=duration_hours
        )
        
        return flood_depth
    
    def identify_risk_zones(self, flood_depth, threshold=0.5):
        # Identify areas with flood depth > threshold
        risk_zones = np.where(flood_depth > threshold, 1, 0)
        
        return risk_zones
    
    def overlay_on_map(self, map_widget, flood_depth):
        # Create raster overlay
        from arcgis.raster import Raster
        
        # Convert flood depth to raster
        flood_raster = Raster.from_numpy_array(
            flood_depth,
            extent=self.dem.extent
        )
        
        # Add to map with transparency
        map_widget.add_layer(flood_raster, {
            "opacity": 0.6,
            "renderer": {
                "type": "stretch",
                "colorRamp": {
                    "type": "algorithmic",
                    "fromColor": [255, 255, 0, 255],
                    "toColor": [255, 0, 0, 255]
                }
            }
        })

# Example usage
from modulus.sym.hydra import instantiate_arch
from modulus.sym.solver import Solver

# Load Modulus model
modulus_model = Solver.load("flood_model.pth")

# Initialize simulator
simulator = FloodSimulator(
    dem_path="/data/elevation/kalobeyei_dem.tif",
    modulus_model=modulus_model
)

# Simulate 100mm rainfall over 6 hours
flood_depth = simulator.simulate_flood(
    rainfall_mm=100,
    duration_hours=6
)

# Identify risk zones
risk_zones = simulator.identify_risk_zones(flood_depth, threshold=0.5)

# Overlay on map
from arcgis.mapping import Map
map_widget = Map()
simulator.overlay_on_map(map_widget, flood_depth)
```

### Real-time runoff simulation

```python
import cupy as cp
from arcgis.raster import Raster

class RunoffSimulator:
    def __init__(self, dem_raster, soil_raster):
        self.dem = dem_raster
        self.soil = soil_raster
        
        # Load data to GPU
        self.elevation_gpu = cp.array(self.dem.read())
        self.soil_type_gpu = cp.array(self.soil.read())
    
    def calculate_runoff(self, rainfall_intensity):
        # Calculate slope
        slope = self._calculate_slope_gpu(self.elevation_gpu)
        
        # Calculate infiltration rate based on soil type
        infiltration = self._calculate_infiltration_gpu(
            self.soil_type_gpu
        )
        
        # Calculate runoff
        runoff = cp.maximum(
            rainfall_intensity - infiltration,
            0
        )
        
        # Apply slope factor
        runoff *= (1 + slope / 10)
        
        return cp.asnumpy(runoff)
    
    def _calculate_slope_gpu(self, elevation):
        # Calculate slope using GPU
        dy, dx = cp.gradient(elevation)
        slope = cp.sqrt(dx**2 + dy**2)
        
        return slope
    
    def _calculate_infiltration_gpu(self, soil_type):
        # Infiltration rates by soil type
        infiltration_map = {
            1: 50,   # Sand (mm/hr)
            2: 25,   # Loam
            3: 10,   # Clay
            4: 5     # Rock
        }
        
        # Map soil types to infiltration rates
        infiltration = cp.zeros_like(soil_type, dtype=cp.float32)
        
        for soil_id, rate in infiltration_map.items():
            infiltration[soil_type == soil_id] = rate
        
        return infiltration
    
    def trace_flow_path(self, start_point):
        # Trace water flow from start point
        elevation = self.elevation_gpu
        
        path = [start_point]
        current = start_point
        
        while True:
            # Find steepest descent
            neighbors = self._get_neighbors(current)
            
            if not neighbors:
                break
            
            # Get elevations
            elevations = [
                elevation[n[0], n[1]] for n in neighbors
            ]
            
            # Find lowest neighbor
            min_idx = cp.argmin(cp.array(elevations))
            next_point = neighbors[int(min_idx)]
            
            # Check if we're going downhill
            if elevation[next_point[0], next_point[1]] >= elevation[current[0], current[1]]:
                break
            
            path.append(next_point)
            current = next_point
        
        return path
    
    def _get_neighbors(self, point):
        # Get 8-connected neighbors
        y, x = point
        neighbors = []
        
        for dy in [-1, 0, 1]:
            for dx in [-1, 0, 1]:
                if dy == 0 and dx == 0:
                    continue
                
                ny, nx = y + dy, x + dx
                
                if (0 <= ny < self.elevation_gpu.shape[0] and
                    0 <= nx < self.elevation_gpu.shape[1]):
                    neighbors.append((ny, nx))
        
        return neighbors
```

## Real-time visualization

### Zero-latency graphic overlay

```python
from arcgis.mapping import Map
from arcgis.geometry import Point, Polyline
import threading

class RealtimeOverlay:
    def __init__(self, map_widget):
        self.map = map_widget
        self.graphics_layer = self.map.add_graphics_layer()
        self.update_thread = None
        self.running = False
    
    def start_realtime_updates(self, data_source, update_interval=1.0):
        # Start real-time update thread
        self.running = True
        self.update_thread = threading.Thread(
            target=self._update_loop,
            args=(data_source, update_interval)
        )
        self.update_thread.start()
    
    def _update_loop(self, data_source, interval):
        while self.running:
            # Get latest data
            data = data_source.get_latest()
            
            # Update graphics
            self._update_graphics(data)
            
            # Wait for next update
            time.sleep(interval)
    
    def _update_graphics(self, data):
        # Clear existing graphics
        self.graphics_layer.clear()
        
        # Add new graphics
        for feature in data:
            if feature["type"] == "point":
                self._add_point(feature)
            elif feature["type"] == "line":
                self._add_line(feature)
            elif feature["type"] == "polygon":
                self._add_polygon(feature)
    
    def _add_point(self, feature):
        # Add point graphic
        point = Point({
            "x": feature["x"],
            "y": feature["y"],
            "spatialReference": {"wkid": 4326}
        })
        
        symbol = {
            "type": "esriSMS",
            "style": "esriSMSCircle",
            "color": feature.get("color", [255, 0, 0, 255]),
            "size": feature.get("size", 10)
        }
        
        self.graphics_layer.add({
            "geometry": point,
            "symbol": symbol,
            "attributes": feature.get("attributes", {})
        })
    
    def add_risk_overlay(self, risk_data, risk_type):
        # Add risk visualization overlay
        color_map = {
            "cholera": [0, 0, 255, 128],      # Blue
            "flood": [0, 255, 255, 128],      # Cyan
            "heat": [255, 0, 0, 128],         # Red
            "radiation": [255, 255, 0, 128]   # Yellow
        }
        
        color = color_map.get(risk_type, [128, 128, 128, 128])
        
        for zone in risk_data:
            self._add_polygon({
                "rings": zone["geometry"],
                "color": color,
                "attributes": {
                    "risk_type": risk_type,
                    "risk_level": zone["risk_level"]
                }
            })
    
    def stop(self):
        self.running = False
        if self.update_thread:
            self.update_thread.join()
```

## Performance optimization

### Spatial indexing

```python
from rtree import index
import json

class SpatialIndex:
    def __init__(self):
        self.idx = index.Index()
        self.features = {}
        self.next_id = 0
    
    def add_feature(self, geometry, attributes):
        # Add feature to spatial index
        bounds = self._get_bounds(geometry)
        
        feature_id = self.next_id
        self.next_id += 1
        
        # Insert into R-tree
        self.idx.insert(feature_id, bounds)
        
        # Store feature
        self.features[feature_id] = {
            "geometry": geometry,
            "attributes": attributes
        }
        
        return feature_id
    
    def query_bbox(self, xmin, ymin, xmax, ymax):
        # Query features within bounding box
        feature_ids = list(self.idx.intersection((xmin, ymin, xmax, ymax)))
        
        results = [
            self.features[fid] for fid in feature_ids
        ]
        
        return results
    
    def query_nearest(self, x, y, k=10):
        # Find k nearest features
        feature_ids = list(self.idx.nearest((x, y, x, y), k))
        
        results = [
            self.features[fid] for fid in feature_ids
        ]
        
        return results
    
    def _get_bounds(self, geometry):
        # Calculate bounding box
        if geometry["type"] == "Point":
            x, y = geometry["coordinates"]
            return (x, y, x, y)
        
        elif geometry["type"] == "LineString":
            coords = geometry["coordinates"]
            xs = [c[0] for c in coords]
            ys = [c[1] for c in coords]
            return (min(xs), min(ys), max(xs), max(ys))
        
        elif geometry["type"] == "Polygon":
            coords = geometry["coordinates"][0]
            xs = [c[0] for c in coords]
            ys = [c[1] for c in coords]
            return (min(xs), min(ys), max(xs), max(ys))
```

## Deployment checklist

<Steps>
  <Step title="Install ArcGIS SDK">
    Install ESRI ArcGIS Maps SDK for Native Apps
  </Step>
  <Step title="Create offline packages">
    Generate .vtpk and .mmpk for target regions
  </Step>
  <Step title="Setup P2P sync">
    Configure Wi-Fi Direct gossip protocol
  </Step>
  <Step title="Deploy Modulus">
    Install NVIDIA Modulus for physics simulation
  </Step>
  <Step title="Test offline mode">
    Verify map rendering without internet
  </Step>
  <Step title="Enable real-time overlay">
    Configure zero-latency risk visualization
  </Step>
</Steps>

## Related documentation

<CardGroup cols={2}>
  <Card title="Spatial Omniscience Stack" icon="map" href="/architecture/spatial-omniscience">
    Architecture overview
  </Card>
  <Card title="ESRI Integration" icon="globe" href="/integrations/esri-geospatial">
    GeoAI and spatial analysis
  </Card>
  <Card title="Nuclear Stack" icon="atom" href="/architecture/nuclear-stack">
    Complete system integration
  </Card>
  <Card title="Deployment" icon="rocket" href="/deployment/overview">
    Production deployment
  </Card>
</CardGroup>
