---
title: AI agents
description: Autonomous disease surveillance with offline operation and federated learning
---

## Overview

iLuminara-Core includes autonomous AI agents designed for offline operation, intermittent connectivity, and edge-to-cloud synchronization with privacy-preserving federated learning capabilities.

<Card
  title="Philosophy"
  icon="brain-circuit"
>
  "Sovereign agents operate with dignity even in digital darkness."
</Card>

## Key features

<CardGroup cols={2}>
  <Card title="Offline operation" icon="wifi-slash">
    Agents operate independently without network connectivity
  </Card>
  <Card title="Intermittent connectivity" icon="signal">
    Intelligent retry logic with exponential backoff
  </Card>
  <Card title="Edge-to-cloud sync" icon="cloud-arrow-up">
    Priority queue syncs critical data first
  </Card>
  <Card title="Federated learning" icon="lock">
    Privacy-preserving collaborative training
  </Card>
</CardGroup>

## Agent types

### Epidemiological forecasting agent

SEIR, SIR, and ARIMA time-series forecasting with R0 estimation.

```python
from edge_node.ai_agents import EpidemiologicalForecastingAgent

agent = EpidemiologicalForecastingAgent(
    location="Nairobi",
    population_size=100000
)

forecast = agent.forecast_outbreak(
    disease="cholera",
    historical_data=historical_cases,
    forecast_horizon_days=14
)

print(f"R0: {forecast.estimated_r0:.2f}")
print(f"Peak cases: {forecast.peak_cases}")
print(f"Peak date: {forecast.peak_date}")
```

### Spatiotemporal analysis agent

Multi-scale spatial clustering and hotspot detection.

```python
from edge_node.ai_agents import SpatiotemporalAnalysisAgent

agent = SpatiotemporalAnalysisAgent(
    location="Dadaab",
    spatial_resolution="district"
)

analysis = agent.analyze_spatial_patterns(
    case_data=cases,
    time_window_days=30
)

print(f"Hotspots detected: {len(analysis.hotspots)}")
print(f"Transmission pathways: {analysis.transmission_pathways}")
```

### Early warning system agent

Real-time multi-source data fusion with <5 second latency.

```python
from edge_node.ai_agents import EarlyWarningSystemAgent

agent = EarlyWarningSystemAgent(
    location="Garissa",
    alert_threshold=0.7
)

# Ingest multiple data sources
agent.ingest_cbs_reports(chv_reports)
agent.ingest_iot_data(sensor_readings)
agent.ingest_emr_data(hospital_records)

# Generate alerts
alerts = agent.generate_alerts()

for alert in alerts:
    print(f"ðŸš¨ {alert.severity}: {alert.message}")
```

### Agent orchestrator

Coordinates all agents for comprehensive analysis.

```python
from edge_node.ai_agents import AgentOrchestrator

orchestrator = AgentOrchestrator(
    location="Nairobi",
    population_size=100000,
    enable_compliance_checking=True
)

# Ingest data
orchestrator.ingest_case_data(case_records)
orchestrator.ingest_cbs_reports(chv_reports)
orchestrator.ingest_iot_data(sensor_readings)

# Run full analysis
result = orchestrator.run_full_analysis(
    diseases=["cholera", "malaria"],
    forecast_horizon_days=14
)

print(f"Status: {result.summary['overall_status']}")
print(f"Alerts: {result.summary['total_alerts']}")
print(f"Max Risk: {result.summary['max_risk_score']}")
```

## Offline operation

Agents queue operations when offline and execute when possible.

```python
from edge_node.ai_agents import OfflineAgent, AgentCapability

agent = OfflineAgent(
    name="Edge Surveillance Agent",
    capabilities=[
        AgentCapability.OFFLINE_OPERATION,
        AgentCapability.AUTONOMOUS_INFERENCE,
    ]
)

# Queue operations while offline
agent.queue_operation("inference", {"data": "..."})
agent.execute_queued_operations()

# Sync when connectivity returns
agent.connectivity.set_connectivity(True)
agent.sync_to_cloud()
```

### Connectivity management

```python
# Check connectivity status
is_online = agent.connectivity.is_connected()

# Get connection history
history = agent.connectivity.get_connection_history()

# Manual sync trigger
agent.check_and_sync()
```

## Federated learning

Privacy-preserving collaborative training without sharing raw data.

```python
from edge_node.ai_agents import FederatedLearningClient

# Hospital A
client_a = FederatedLearningClient(
    name="Hospital A Client",
    epsilon=1.0,  # Privacy budget
    delta=1e-5,   # Privacy relaxation
)

# Train on local data (never leaves device)
training_data = [{"features": [...], "label": 0}, ...]
client_a.train_local_model(training_data, epochs=5)

# Generate privacy-preserving update
update_a = client_a.get_model_update(apply_privacy=True)

# Apply aggregated global model
client_a.apply_global_model(global_model)

# Check privacy budget
privacy = client_a.compute_privacy_spent()
print(f"Privacy spent: Îµ={privacy['epsilon']}, Î´={privacy['delta']}")
```

### Privacy guarantees

The federated learning implementation provides (Îµ, Î´)-differential privacy:

- **Epsilon (Îµ)**: Privacy budget (lower = more privacy)
  - Îµ = 0.1: Very strong privacy
  - Îµ = 1.0: Strong privacy (default)
  - Îµ > 10: Weak privacy

- **Delta (Î´)**: Privacy relaxation (typically 1e-5)

### Privacy mechanisms

<Steps>
  <Step title="Gradient clipping">
    Bounds sensitivity to limit impact of outliers
  </Step>
  <Step title="Laplacian noise">
    Adds calibrated noise to gradients
  </Step>
  <Step title="Privacy accounting">
    Tracks cumulative privacy loss across rounds
  </Step>
  <Step title="Secure aggregation">
    Combines updates without revealing individuals
  </Step>
</Steps>

## Agent registry

Discovery service for finding and matching agents.

```python
from edge_node.ai_agents import AgentRegistry, AgentCapability

registry = AgentRegistry()

# Register agents
registry.register(agent1)
registry.register(agent2)

# Search by capabilities
offline_agents = registry.search_by_capabilities([
    AgentCapability.OFFLINE_OPERATION
])

# Search by tags
health_agents = registry.search_by_tags(["health", "surveillance"])

# Advanced search
results = registry.advanced_search(
    capabilities=[AgentCapability.FEDERATED_LEARNING],
    tags=["hospital"],
    status=AgentStatus.ONLINE
)
```

## Agent capabilities

```python
class AgentCapability(Enum):
    OFFLINE_OPERATION = "offline_operation"
    INTERMITTENT_CONNECTIVITY = "intermittent_connectivity"
    EDGE_TO_CLOUD_SYNC = "edge_to_cloud_sync"
    FEDERATED_LEARNING = "federated_learning"
    PRIVACY_PRESERVING = "privacy_preserving"
    AUTONOMOUS_INFERENCE = "autonomous_inference"
    LOCAL_STORAGE = "local_storage"
    MODEL_UPDATE = "model_update"
    DATA_SYNC = "data_sync"
```

## Compliance integration

AI Agents integrate with iLuminara's governance kernel:

```python
from governance_kernel.vector_ledger import SovereignGuardrail
from edge_node.ai_agents import FederatedLearningClient

# Create agent with compliance validation
client = FederatedLearningClient(name="Compliant Agent")

# Governance validation
guardrail = SovereignGuardrail()
guardrail.validate_action(
    action_type='High_Risk_Inference',
    payload={
        'inference': 'diagnosis',
        'explanation': client.local_model,
        'confidence_score': 0.92,
        'evidence_chain': [...]
    },
    jurisdiction='GDPR_EU'
)
```

## Use cases

### Remote health surveillance

Deploy agents in remote areas with unreliable connectivity:

```python
agent = OfflineAgent(
    name="Remote Health Monitor",
    capabilities=[
        AgentCapability.OFFLINE_OPERATION,
        AgentCapability.AUTONOMOUS_INFERENCE,
        AgentCapability.LOCAL_STORAGE,
    ],
    tags=["health", "remote", "surveillance"]
)

# Agent operates autonomously even without network
agent.queue_operation("inference", {
    "patient_id": "P001",
    "symptoms": ["fever", "cough"],
    "vital_signs": {"temp": 38.5, "hr": 95}
})

# Data syncs when connectivity returns
agent.check_and_sync()
```

### Privacy-preserving collaborative learning

Enable multiple hospitals to collaboratively train models without sharing patient data:

```python
# Hospital A
client_a = FederatedLearningClient(name="Hospital A", epsilon=1.0)
client_a.train_local_model(local_data_a)
update_a = client_a.get_model_update(apply_privacy=True)

# Hospital B
client_b = FederatedLearningClient(name="Hospital B", epsilon=1.0)
client_b.train_local_model(local_data_b)
update_b = client_b.get_model_update(apply_privacy=True)

# Central server aggregates (no raw data shared)
aggregated_model = aggregate_updates([update_a, update_b])

# Distribute back to clients
client_a.apply_global_model(aggregated_model)
client_b.apply_global_model(aggregated_model)
```

## Testing

Run the comprehensive test suite:

```bash
python tests/test_ai_agents.py
```

Run the full demonstration:

```bash
python examples/offline_agents_demo.py
```

## Next steps

<CardGroup cols={2}>
  <Card
    title="Architecture"
    icon="sitemap"
    href="/architecture/overview"
  >
    Understand the four foundational pillars
  </Card>
  <Card
    title="Golden Thread"
    icon="link"
    href="/architecture/golden-thread"
  >
    Data fusion engine
  </Card>
  <Card
    title="Governance"
    icon="shield-check"
    href="/governance/overview"
  >
    Integrate with governance kernel
  </Card>
  <Card
    title="Deployment"
    icon="rocket"
    href="/deployment/overview"
  >
    Deploy to production
  </Card>
</CardGroup>
